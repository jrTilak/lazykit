[
  {
    "name": "and",
    "code": {
      "ts": "/**\n * Performs a logical AND operation on the given arguments.\n **/\nconst and = (...args: unknown[]) => {\n  if (args.length === 0) return false;\n  return args.every((arg) => Boolean(arg));\n};\n\nexport default and;\n",
      "js": "/**\n * Performs a logical AND operation on the given arguments.\n **/\nconst and = (...args) => {\n  if (args.length === 0) return false;\n  return args.every((arg) => Boolean(arg));\n};\nexport default and;\n"
    },
    "category": "gates",
    "type": "functions"
  },
  {
    "name": "callAfter",
    "code": {
      "ts": "/**\n * Returns a new function that can be called only after calling a specific number of times.\n **/\nconst callAfter = <T, S extends any[]>(\n  fn: (...args: S) => T,\n  count: number,\n): ((...args: S) => T | undefined) => {\n  let counter = 0;\n  return (...args: S): T | undefined => {\n    if (counter < count) {\n      counter++;\n      return undefined;\n    }\n    return fn(...args);\n  };\n};\n\nexport default callAfter;\n",
      "js": "/**\n * Returns a new function that can be called only after calling a specific number of times.\n **/\nconst callAfter = (fn, count) => {\n  let counter = 0;\n  return (...args) => {\n    if (counter < count) {\n      counter++;\n      return undefined;\n    }\n    return fn(...args);\n  };\n};\nexport default callAfter;\n"
    },
    "category": "functional",
    "type": "functions"
  },
  {
    "name": "callBefore",
    "code": {
      "ts": "/**\n * Returns a new function that can be called only for specific number of times.\n **/\nconst callBefore = <T, S extends any[]>(\n  fn: (...args: S) => T,\n  count: number,\n): ((...args: S) => T | undefined) => {\n  let counter = 0;\n  return (...args: S): T | undefined => {\n    if (counter < count) {\n      counter++;\n      return fn(...args);\n    }\n    return undefined;\n  };\n};\n\nexport default callBefore;\n",
      "js": "/**\n * Returns a new function that can be called only for specific number of times.\n **/\nconst callBefore = (fn, count) => {\n  let counter = 0;\n  return (...args) => {\n    if (counter < count) {\n      counter++;\n      return fn(...args);\n    }\n    return undefined;\n  };\n};\nexport default callBefore;\n"
    },
    "category": "functional",
    "type": "functions"
  },
  {
    "name": "chunk",
    "code": {
      "ts": "/**\n * Chunks an array into smaller arrays of a specified size.\n **/\nconst chunk = <T,>(\n  array: T[],\n  size: number,\n  config?: {\n    style: 'normal' | 'repeat' | 'remove';\n  },\n): T[][] => {\n  const result: T[][] = [];\n\n  // Push the chunks into the result array\n  for (let i = 0; i < array.length; i += size) {\n    result.push(array.slice(i, i + size));\n  }\n\n  if (config?.style === 'remove' && result[result.length - 1].length !== size) {\n    result.pop(); // Remove the last chunk if it doesn't match the size\n  } else if (config?.style === 'repeat') {\n    // Repeat elements from the start if the last chunk is smaller\n    const lastChunk = result[result.length - 1];\n    if (lastChunk.length < size) {\n      const elementsNeeded = size - lastChunk.length;\n      const repeatedElements = array.slice(0, elementsNeeded); // Get elements from the start\n      result[result.length - 1] = lastChunk.concat(repeatedElements); // Fill the last chunk\n    }\n  }\n\n  return result;\n};\n\nexport default chunk;\n",
      "js": "/**\n * Chunks an array into smaller arrays of a specified size.\n **/\nconst chunk = (array, size, config) => {\n  const result = [];\n  // Push the chunks into the result array\n  for (let i = 0; i < array.length; i += size) {\n    result.push(array.slice(i, i + size));\n  }\n  if (config?.style === 'remove' && result[result.length - 1].length !== size) {\n    result.pop(); // Remove the last chunk if it doesn't match the size\n  } else if (config?.style === 'repeat') {\n    // Repeat elements from the start if the last chunk is smaller\n    const lastChunk = result[result.length - 1];\n    if (lastChunk.length < size) {\n      const elementsNeeded = size - lastChunk.length;\n      const repeatedElements = array.slice(0, elementsNeeded); // Get elements from the start\n      result[result.length - 1] = lastChunk.concat(repeatedElements); // Fill the last chunk\n    }\n  }\n  return result;\n};\nexport default chunk;\n"
    },
    "category": "arrays",
    "type": "functions"
  },
  {
    "name": "compact",
    "code": {
      "ts": "/**\n * Removes falsy values from an array, If extend is true, also removes empty objects and arrays.\n **/\nconst compact = <T,>(array: T[], extend: boolean = false): T[] => {\n  let truthy = array.filter((item) => {\n    // remove all falsy values and excluded values\n    return Boolean(item);\n  });\n\n  if (extend) {\n    // remove all empty objects\n    truthy = truthy.filter((item) => {\n      if (typeof item === 'object' && !(item instanceof Array)) {\n        return Object.keys(item as object).length > 0;\n      }\n      return true;\n    });\n    // remove all empty arrays\n    truthy = truthy.filter((item) => {\n      if (Array.isArray(item)) {\n        return (item as []).length > 0;\n      }\n      return true;\n    });\n  }\n  return truthy;\n};\n\nexport default compact;\n",
      "js": "/**\n * Removes falsy values from an array, If extend is true, also removes empty objects and arrays.\n **/\nconst compact = (array, extend = false) => {\n  let truthy = array.filter((item) => {\n    // remove all falsy values and excluded values\n    return Boolean(item);\n  });\n  if (extend) {\n    // remove all empty objects\n    truthy = truthy.filter((item) => {\n      if (typeof item === 'object' && !(item instanceof Array)) {\n        return Object.keys(item).length > 0;\n      }\n      return true;\n    });\n    // remove all empty arrays\n    truthy = truthy.filter((item) => {\n      if (Array.isArray(item)) {\n        return item.length > 0;\n      }\n      return true;\n    });\n  }\n  return truthy;\n};\nexport default compact;\n"
    },
    "category": "arrays",
    "type": "functions"
  },
  {
    "name": "count",
    "code": {
      "ts": "/**\n * returns the result of a function and the number of times that function is invoked.\n **/\nconst count = <A extends any[], R>(fn: (...args: A) => R) => {\n  let callCount = 0;\n\n  const wrapper = (...args: A): R => {\n    callCount++;\n    const result = fn(...args);\n    return result;\n  };\n\n  const getCount: () => number = () => callCount;\n  wrapper.getCount = getCount;\n\n  return wrapper;\n};\n\nexport default count;\n",
      "js": "/**\n * returns the result of a function and the number of times that function is invoked.\n **/\nconst count = (fn) => {\n  let callCount = 0;\n  const wrapper = (...args) => {\n    callCount++;\n    const result = fn(...args);\n    return result;\n  };\n  const getCount = () => callCount;\n  wrapper.getCount = getCount;\n  return wrapper;\n};\nexport default count;\n"
    },
    "category": "functional",
    "type": "functions"
  },
  {
    "name": "debounce",
    "code": {
      "ts": "/**\n * Returns a debounced function that delays invoking the passed function until after `given` milliseconds have elapsed since the last time the debounced function was invoked.\n **/\n\nfunction debounce<A extends unknown[]>(\n  fn: (...args: A) => void,\n  delay: number = 300,\n) {\n  let timer: any;\n  return (...args: A) => {\n    clearTimeout(timer);\n    timer = setTimeout(() => {\n      fn(...args);\n    }, delay);\n  };\n}\n\nexport default debounce;\n",
      "js": "/**\n * Returns a debounced function that delays invoking the passed function until after `given` milliseconds have elapsed since the last time the debounced function was invoked.\n **/\nfunction debounce(fn, delay = 300) {\n  let timer;\n  return (...args) => {\n    clearTimeout(timer);\n    timer = setTimeout(() => {\n      fn(...args);\n    }, delay);\n  };\n}\nexport default debounce;\n"
    },
    "category": "functional",
    "type": "functions"
  },
  {
    "name": "filterObj",
    "code": {
      "ts": "/**\n * Same as Array.prototype.filter, but for objects.\n **/\nconst filterObj = <T extends Record<string, unknown>>(\n  obj: T,\n  predicate: (value: T[keyof T], key: keyof T) => boolean,\n): Partial<T> => {\n  const result: Partial<T> = {};\n\n  for (const key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      if (predicate(obj[key], key)) {\n        result[key] = obj[key]; // Include the property if the predicate returns true\n      }\n    }\n  }\n\n  return result;\n};\n\nexport default filterObj;\n",
      "js": "/**\n * Same as Array.prototype.filter, but for objects.\n **/\nconst filterObj = (obj, predicate) => {\n  const result = {};\n  for (const key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      if (predicate(obj[key], key)) {\n        result[key] = obj[key]; // Include the property if the predicate returns true\n      }\n    }\n  }\n  return result;\n};\nexport default filterObj;\n"
    },
    "category": "objects",
    "type": "functions"
  },
  {
    "name": "getLocalStorageItem",
    "code": {
      "ts": "/**\n * Retrieves a value from local storage with optional parsing and a default return.\n **/\ntype GetConfig<Value> =\n  | {\n      defaultParser: boolean;\n    }\n  | ((storedValue: string) => Value);\n\nconst getLocalStorageItem = <Value,>(\n  key: string,\n  defaultValue: Value,\n  config: GetConfig<Value> = {\n    defaultParser: true,\n  },\n): Value => {\n  if (typeof window === 'undefined' || !('localStorage' in window)) {\n    return defaultValue;\n  }\n\n  const storedValue = localStorage.getItem(key);\n  if (!storedValue) return defaultValue;\n\n  try {\n    if (typeof config === 'object' && config.defaultParser) {\n      return JSON.parse(storedValue) as Value;\n    } else if (typeof config === 'function') {\n      return config(storedValue);\n    }\n    return storedValue as unknown as Value;\n  } catch {\n    return defaultValue;\n  }\n};\n\nexport default getLocalStorageItem;\n",
      "js": "const getLocalStorageItem = (\n  key,\n  defaultValue,\n  config = {\n    defaultParser: true,\n  },\n) => {\n  if (typeof window === 'undefined' || !('localStorage' in window)) {\n    return defaultValue;\n  }\n  const storedValue = localStorage.getItem(key);\n  if (!storedValue) return defaultValue;\n  try {\n    if (typeof config === 'object' && config.defaultParser) {\n      return JSON.parse(storedValue);\n    } else if (typeof config === 'function') {\n      return config(storedValue);\n    }\n    return storedValue;\n  } catch {\n    return defaultValue;\n  }\n};\nexport default getLocalStorageItem;\n"
    },
    "category": "web-api",
    "type": "functions"
  },
  {
    "name": "insert",
    "code": {
      "ts": "/**\n * Inserts elements into an array at a specified index.\n **/\nconst insert = <T,>(\n  arr: T[],\n  index: number,\n  [...items]: T[],\n  recursive: boolean = false,\n): T[] => {\n  const isNegativeIndex = index < 0;\n\n  if (isNegativeIndex) {\n    throw new Error('Negative index is not supported!');\n  }\n\n  if (!recursive) {\n    const newArr = [...arr.slice(0, index), ...items, ...arr.slice(index)];\n    return newArr;\n  } else {\n    const shouldInsert = Math.floor(arr.length / index);\n    let newArr = [...arr];\n    for (let i = 0; i < shouldInsert; i++) {\n      const insertIndex = (i + 1) * index + i * items.length;\n      newArr = [\n        ...newArr.slice(0, insertIndex),\n        ...items,\n        ...newArr.slice(insertIndex),\n      ];\n    }\n    return newArr;\n  }\n};\n\nexport default insert;\n",
      "js": "/**\n * Inserts elements into an array at a specified index.\n **/\nconst insert = (arr, index, [...items], recursive = false) => {\n  const isNegativeIndex = index < 0;\n  if (isNegativeIndex) {\n    throw new Error('Negative index is not supported!');\n  }\n  if (!recursive) {\n    const newArr = [...arr.slice(0, index), ...items, ...arr.slice(index)];\n    return newArr;\n  } else {\n    const shouldInsert = Math.floor(arr.length / index);\n    let newArr = [...arr];\n    for (let i = 0; i < shouldInsert; i++) {\n      const insertIndex = (i + 1) * index + i * items.length;\n      newArr = [\n        ...newArr.slice(0, insertIndex),\n        ...items,\n        ...newArr.slice(insertIndex),\n      ];\n    }\n    return newArr;\n  }\n};\nexport default insert;\n"
    },
    "category": "arrays",
    "type": "functions"
  },
  {
    "name": "mapObj",
    "code": {
      "ts": "/**\n * Same as Array.prototype.map, but for objects.\n **/\nconst mapObj = <T, U>(\n  obj: Record<string, T>,\n  callback: (value: T, key: string, obj: Record<string, T>) => U,\n): Record<string, U> => {\n  const result: Record<string, U> = {};\n\n  // loop through each key in the object\n  for (const key in obj) {\n    // check if the key is a property of the object\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      result[key] = callback(obj[key], key, obj);\n    }\n  }\n\n  return result;\n};\n\nexport default mapObj;\n",
      "js": "/**\n * Same as Array.prototype.map, but for objects.\n **/\nconst mapObj = (obj, callback) => {\n  const result = {};\n  // loop through each key in the object\n  for (const key in obj) {\n    // check if the key is a property of the object\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      result[key] = callback(obj[key], key, obj);\n    }\n  }\n  return result;\n};\nexport default mapObj;\n"
    },
    "category": "objects",
    "type": "functions"
  },
  {
    "name": "nTimes",
    "code": {
      "ts": "/**\n * Calls a function n times and returns an array of the results.\n **/\n\n/**\n * Calls a function n times and returns an array of the results.\n **/\n\nconst nTimes = <T,>(fn: (i: number) => T, n: number = 1): T[] => {\n  if (n < 0) {\n    throw new Error('n must be greater than 0');\n  }\n  let result: T[] = [];\n  for (let i = 0; i < n; i++) {\n    result.push(fn(i));\n  }\n  return result;\n};\n\nexport default nTimes;\n",
      "js": "/**\n * Calls a function n times and returns an array of the results.\n **/\n/**\n * Calls a function n times and returns an array of the results.\n **/\nconst nTimes = (fn, n = 1) => {\n  if (n < 0) {\n    throw new Error('n must be greater than 0');\n  }\n  let result = [];\n  for (let i = 0; i < n; i++) {\n    result.push(fn(i));\n  }\n  return result;\n};\nexport default nTimes;\n"
    },
    "category": "functional",
    "type": "functions"
  },
  {
    "name": "nand",
    "code": {
      "ts": "/**\n * Performs a logical NAND operation on the given arguments.\n **/\n\nconst nand = (...args: unknown[]) => {\n  if (args.length === 0) return false;\n  const and = args.every((arg) => Boolean(arg));\n  return !and;\n};\n\nexport default nand;\n",
      "js": "/**\n * Performs a logical NAND operation on the given arguments.\n **/\nconst nand = (...args) => {\n  if (args.length === 0) return false;\n  const and = args.every((arg) => Boolean(arg));\n  return !and;\n};\nexport default nand;\n"
    },
    "category": "gates",
    "type": "functions"
  },
  {
    "name": "nor",
    "code": {
      "ts": "/**\n * Performs a logical NOR operation on the given arguments.\n **/\nconst nor = (...args: unknown[]) => {\n  if (args.length === 0) return false;\n  const or = args.some((arg) => Boolean(arg));\n  return !or;\n};\n\nexport default nor;\n",
      "js": "/**\n * Performs a logical NOR operation on the given arguments.\n **/\nconst nor = (...args) => {\n  if (args.length === 0) return false;\n  const or = args.some((arg) => Boolean(arg));\n  return !or;\n};\nexport default nor;\n"
    },
    "category": "gates",
    "type": "functions"
  },
  {
    "name": "omit",
    "code": {
      "ts": "/**\n * Returns a new object with the specified keys omitted.\n **/\nconst omit = <T, K extends keyof T>(obj: T, keys: K[]): Omit<T, K> => {\n  const newObj = { ...obj };\n  keys.forEach((key) => delete newObj[key]);\n  return newObj as Omit<T, K>;\n};\n\nexport default omit;\n",
      "js": "/**\n * Returns a new object with the specified keys omitted.\n **/\nconst omit = (obj, keys) => {\n  const newObj = { ...obj };\n  keys.forEach((key) => delete newObj[key]);\n  return newObj;\n};\nexport default omit;\n"
    },
    "category": "objects",
    "type": "functions"
  },
  {
    "name": "once",
    "code": {
      "ts": "/**\n * Returns a new function that can be called only once.\n **/\nconst once = <T, S extends any[]>(\n  fn: (...args: S) => T,\n): ((...args: S) => T | undefined) => {\n  let isCalled = false;\n  return (...args: S): T | undefined => {\n    if (!isCalled) {\n      isCalled = true;\n      return fn(...args);\n    }\n    return undefined;\n  };\n};\n\nexport default once;\n",
      "js": "/**\n * Returns a new function that can be called only once.\n **/\nconst once = (fn) => {\n  let isCalled = false;\n  return (...args) => {\n    if (!isCalled) {\n      isCalled = true;\n      return fn(...args);\n    }\n    return undefined;\n  };\n};\nexport default once;\n"
    },
    "category": "functional",
    "type": "functions"
  },
  {
    "name": "or",
    "code": {
      "ts": "/**\n * Performs a logical OR operation on the given arguments.\n **/\nconst or = (...args: unknown[]) => {\n  return args.some((arg) => Boolean(arg));\n};\n\nexport default or;\n",
      "js": "/**\n * Performs a logical OR operation on the given arguments.\n **/\nconst or = (...args) => {\n  return args.some((arg) => Boolean(arg));\n};\nexport default or;\n"
    },
    "category": "gates",
    "type": "functions"
  },
  {
    "name": "partition",
    "code": {
      "ts": "/**\n * Partitions an array into two arrays based on a given callback ie predicate.\n **/\nconst partition = <T,>(\n  arr: T[],\n  predicate: (value: T, i: number, arr: T[]) => boolean,\n): [T[], T[]] => {\n  const pass: T[] = [];\n  const fail: T[] = [];\n  arr.forEach((...args) => {\n    // run the predicate function on each element in the array\n    // and push the element to the appropriate array\n    (predicate(...args) ? pass : fail).push(args[0]);\n  });\n  return [pass, fail];\n};\n\nexport default partition;\n",
      "js": "/**\n * Partitions an array into two arrays based on a given callback ie predicate.\n **/\nconst partition = (arr, predicate) => {\n  const pass = [];\n  const fail = [];\n  arr.forEach((...args) => {\n    // run the predicate function on each element in the array\n    // and push the element to the appropriate array\n    (predicate(...args) ? pass : fail).push(args[0]);\n  });\n  return [pass, fail];\n};\nexport default partition;\n"
    },
    "category": "arrays",
    "type": "functions"
  },
  {
    "name": "pick",
    "code": {
      "ts": "/**\n * Picks the specified keys from an object.\n **/\nconst pick = <T, K extends keyof T>(obj: T, keys: K[]): Pick<T, K> => {\n  const newObj: any = {};\n  keys.forEach((key) => {\n    newObj[key] = obj[key];\n  });\n  return newObj as Pick<T, K>;\n};\n\nexport default pick;\n",
      "js": "/**\n * Picks the specified keys from an object.\n **/\nconst pick = (obj, keys) => {\n  const newObj = {};\n  keys.forEach((key) => {\n    newObj[key] = obj[key];\n  });\n  return newObj;\n};\nexport default pick;\n"
    },
    "category": "objects",
    "type": "functions"
  },
  {
    "name": "remove",
    "code": {
      "ts": "/**\n * Removes elements from an array at a specified index.\n **/\nconst remove = <T,>(array: T[], index: number | number[]): T[] => {\n  const len = array.length;\n  if (Array.isArray(index)) {\n    // convert negative indices to their positive counterparts\n    const indices = index.map((i) => (i < 0 ? len + i : i));\n    return array.filter((_, i) => !indices.includes(i));\n  }\n  index = index < 0 ? len + index : index;\n  return array.filter((_, i) => i !== index);\n};\n\nexport default remove;\n",
      "js": "/**\n * Removes elements from an array at a specified index.\n **/\nconst remove = (array, index) => {\n  const len = array.length;\n  if (Array.isArray(index)) {\n    // convert negative indices to their positive counterparts\n    const indices = index.map((i) => (i < 0 ? len + i : i));\n    return array.filter((_, i) => !indices.includes(i));\n  }\n  index = index < 0 ? len + index : index;\n  return array.filter((_, i) => i !== index);\n};\nexport default remove;\n"
    },
    "category": "arrays",
    "type": "functions"
  },
  {
    "name": "renameKeys",
    "code": {
      "ts": "/**\n * Renames keys in an object.\n **/\nconst renameKeys = <\n  T extends Record<string, unknown>,\n  K extends keyof T,\n  N extends string,\n>(\n  obj: T,\n  keys: Array<{ old: K; new: N }>,\n): Omit<T, K> & Record<N, T[K]> => {\n  const newObj: Record<string, unknown> = { ...obj };\n\n  keys.forEach(({ old: oldKey, new: newKey }) => {\n    // Only rename if the old key exists in the object\n    if (oldKey in newObj) {\n      newObj[newKey] = newObj[oldKey as string];\n      delete newObj[oldKey as string];\n    }\n  });\n\n  return newObj as Omit<T, K> & Record<N, T[K]>;\n};\n\nexport default renameKeys;\n",
      "js": "/**\n * Renames keys in an object.\n **/\nconst renameKeys = (obj, keys) => {\n  const newObj = { ...obj };\n  keys.forEach(({ old: oldKey, new: newKey }) => {\n    // Only rename if the old key exists in the object\n    if (oldKey in newObj) {\n      newObj[newKey] = newObj[oldKey];\n      delete newObj[oldKey];\n    }\n  });\n  return newObj;\n};\nexport default renameKeys;\n"
    },
    "category": "objects",
    "type": "functions"
  },
  {
    "name": "renameKeysByCallback",
    "code": {
      "ts": "/**\n * Renames keys in an object using a given callback function.\n **/\nconst renameKeysByCallback = <\n  T extends Record<string, unknown>,\n  R extends Record<string, any>,\n>(\n  obj: T,\n  cb: (key: keyof T) => string,\n): R => {\n  const newObj: Record<string, any> = { ...obj };\n\n  for (const key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      const newKey = cb(key);\n      if (newKey) {\n        newObj[newKey] = obj[key]; // Assign the value to the new key\n        delete newObj[key]; // Delete the old key\n      }\n    }\n  }\n\n  return newObj as R;\n};\n\nexport default renameKeysByCallback;\n",
      "js": "/**\n * Renames keys in an object using a given callback function.\n **/\nconst renameKeysByCallback = (obj, cb) => {\n  const newObj = { ...obj };\n  for (const key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      const newKey = cb(key);\n      if (newKey) {\n        newObj[newKey] = obj[key]; // Assign the value to the new key\n        delete newObj[key]; // Delete the old key\n      }\n    }\n  }\n  return newObj;\n};\nexport default renameKeysByCallback;\n"
    },
    "category": "objects",
    "type": "functions"
  },
  {
    "name": "retry",
    "code": {
      "ts": "/**\n * Retries the given function a specified number of times with a delay between each retry.\n **/\nconst retry = async <T,>(\n  fn: Function,\n  retries: number = 3,\n  delay: number = 1000,\n): Promise<T> => {\n  try {\n    return await fn();\n  } catch (error) {\n    if (retries > 0) {\n      await new Promise((resolve) => setTimeout(resolve, delay));\n      return retry(fn, retries - 1, delay);\n    }\n    throw error;\n  }\n};\n\nexport default retry;\n",
      "js": "/**\n * Retries the given function a specified number of times with a delay between each retry.\n **/\nconst retry = async (fn, retries = 3, delay = 1000) => {\n  try {\n    return await fn();\n  } catch (error) {\n    if (retries > 0) {\n      await new Promise((resolve) => setTimeout(resolve, delay));\n      return retry(fn, retries - 1, delay);\n    }\n    throw error;\n  }\n};\nexport default retry;\n"
    },
    "category": "functional",
    "type": "functions"
  },
  {
    "name": "rotate",
    "code": {
      "ts": "/**\n * Rotates the elements of an array by a given number of positions.\n **/\nconst rotate = <T,>(\n  arr: T[],\n  n: number,\n  dir: 'left' | 'right' = 'left',\n): T[] => {\n  if (dir === 'left') {\n    return arr.slice(n, arr.length).concat(arr.slice(0, n));\n  } else {\n    return arr\n      .slice(arr.length - n, arr.length)\n      .concat(arr.slice(0, arr.length - n));\n  }\n};\n\nexport default rotate;\n",
      "js": "/**\n * Rotates the elements of an array by a given number of positions.\n **/\nconst rotate = (arr, n, dir = 'left') => {\n  if (dir === 'left') {\n    return arr.slice(n, arr.length).concat(arr.slice(0, n));\n  } else {\n    return arr\n      .slice(arr.length - n, arr.length)\n      .concat(arr.slice(0, arr.length - n));\n  }\n};\nexport default rotate;\n"
    },
    "category": "arrays",
    "type": "functions"
  },
  {
    "name": "sampleArr",
    "code": {
      "ts": "/**\n * Generates an array of random numbers.\n **/\nconst sampleArr = (size: number) => {\n  if (size < 0) throw new Error('Size must be a positive number');\n  return Array.from({ length: size }, (_, i) => Math.floor(Math.random() * i));\n};\n\nexport default sampleArr;\n",
      "js": "/**\n * Generates an array of random numbers.\n **/\nconst sampleArr = (size) => {\n  if (size < 0) throw new Error('Size must be a positive number');\n  return Array.from({ length: size }, (_, i) => Math.floor(Math.random() * i));\n};\nexport default sampleArr;\n"
    },
    "category": "arrays",
    "type": "functions"
  },
  {
    "name": "sampleObj",
    "code": {
      "ts": "/**\n * Returns a sample object with the specified keys and values as random numbers.\n **/\nconst sampleObj = <R extends Record<string | number | symbol, number>>(\n  ...keys: string[]\n) => {\n  const obj: any = {};\n  keys.forEach((key) => {\n    obj[key] = Math.random();\n  });\n  return obj as R | Record<string, number>;\n};\n\nexport default sampleObj;\n",
      "js": "/**\n * Returns a sample object with the specified keys and values as random numbers.\n **/\nconst sampleObj = (...keys) => {\n  const obj = {};\n  keys.forEach((key) => {\n    obj[key] = Math.random();\n  });\n  return obj;\n};\nexport default sampleObj;\n"
    },
    "category": "objects",
    "type": "functions"
  },
  {
    "name": "setLocalStorageItem",
    "code": {
      "ts": "/**\n * Stores a value in local storage with optional parsing.\n **/\ntype Config<Value> =\n  | {\n      defaultParser: boolean;\n    }\n  | ((value: Value) => string);\n\nconst setLocalStorageItem = <Value,>(\n  key: string,\n  value: unknown,\n  config: Config<Value> = {\n    defaultParser: true,\n  },\n): boolean => {\n  if (typeof window === 'undefined' || !('localStorage' in window)) {\n    return false;\n  }\n\n  try {\n    let parsed: string = '';\n    if (typeof config === 'object' && config.defaultParser) {\n      if (typeof value === 'object' || Array.isArray(value)) {\n        parsed = JSON.stringify(value);\n      } else {\n        parsed = value as string;\n      }\n    } else if (typeof config === 'function') {\n      parsed = config(value as Value);\n    } else {\n      parsed = value as string;\n    }\n    localStorage.setItem(key, parsed);\n    return true;\n  } catch {\n    return false;\n  }\n};\n\nexport default setLocalStorageItem;\n",
      "js": "const setLocalStorageItem = (\n  key,\n  value,\n  config = {\n    defaultParser: true,\n  },\n) => {\n  if (typeof window === 'undefined' || !('localStorage' in window)) {\n    return false;\n  }\n  try {\n    let parsed = '';\n    if (typeof config === 'object' && config.defaultParser) {\n      if (typeof value === 'object' || Array.isArray(value)) {\n        parsed = JSON.stringify(value);\n      } else {\n        parsed = value;\n      }\n    } else if (typeof config === 'function') {\n      parsed = config(value);\n    } else {\n      parsed = value;\n    }\n    localStorage.setItem(key, parsed);\n    return true;\n  } catch {\n    return false;\n  }\n};\nexport default setLocalStorageItem;\n"
    },
    "category": "web-api",
    "type": "functions"
  },
  {
    "name": "shuffleArr",
    "code": {
      "ts": "/**\n * Shuffles the elements of an array using Fisher-Yates algorithm.\n **/\nconst shuffleArr = <T,>(arr: T[]) => {\n  const copy = [...arr];\n  for (let i = copy.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [copy[i], copy[j]] = [copy[j], copy[i]];\n  }\n\n  return copy;\n};\n\nexport default shuffleArr;\n",
      "js": "/**\n * Shuffles the elements of an array using Fisher-Yates algorithm.\n **/\nconst shuffleArr = (arr) => {\n  const copy = [...arr];\n  for (let i = copy.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [copy[i], copy[j]] = [copy[j], copy[i]];\n  }\n  return copy;\n};\nexport default shuffleArr;\n"
    },
    "category": "arrays",
    "type": "functions"
  },
  {
    "name": "sleep",
    "code": {
      "ts": "/**\n * Sleeps the execution for the specified number of milliseconds.\n **/\nconst sleep = (ms: number): Promise<true> => {\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      resolve(true);\n    }, ms);\n  });\n};\n\nexport default sleep;\n",
      "js": "/**\n * Sleeps the execution for the specified number of milliseconds.\n **/\nconst sleep = (ms) => {\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      resolve(true);\n    }, ms);\n  });\n};\nexport default sleep;\n"
    },
    "category": "functional",
    "type": "functions"
  },
  {
    "name": "throttle",
    "code": {
      "ts": "/**\n * Return a throttled function that invokes the passed function at most once per every `given` milliseconds.\n **/\n\nfunction throttle<A extends any[]>(\n  fn: (...args: A) => void,\n  limit: number,\n): (...args: A) => void {\n  let lastCall = 0;\n  return (...args: A) => {\n    const now = Date.now();\n    if (now - lastCall >= limit) {\n      lastCall = now;\n      fn(...args);\n    }\n  };\n}\n\nexport default throttle;\n",
      "js": "/**\n * Return a throttled function that invokes the passed function at most once per every `given` milliseconds.\n **/\nfunction throttle(fn, limit) {\n  let lastCall = 0;\n  return (...args) => {\n    const now = Date.now();\n    if (now - lastCall >= limit) {\n      lastCall = now;\n      fn(...args);\n    }\n  };\n}\nexport default throttle;\n"
    },
    "category": "functional",
    "type": "functions"
  },
  {
    "name": "timeout",
    "code": {
      "ts": "/**\n * The timeout function wraps a function with a timeout. If the function does not complete within the specified time, the promise will be rejected.\n **/\nconst timeout = <Return, Err>(\n  fn: (...args: any[]) => Return,\n  time: number,\n  errCb?: (...args: any[]) => Err,\n): ((...args: any[]) => Promise<Return>) => {\n  return (...args: any[]) => {\n    return new Promise<any>((resolve, reject) => {\n      const timer = setTimeout(() => {\n        if (errCb) reject(errCb(...args));\n        else {\n          reject(new Error('Function timed out'));\n        }\n      }, time);\n\n      // Wrap fn call in Promise.resolve to handle both sync and async functions\n      Promise.resolve(fn(...args))\n        .then((result: Return) => {\n          clearTimeout(timer);\n          resolve(result);\n        })\n        .catch((err: Err) => {\n          clearTimeout(timer);\n          reject(err);\n        });\n    });\n  };\n};\n\nexport default timeout;\n",
      "js": "/**\n * The timeout function wraps a function with a timeout. If the function does not complete within the specified time, the promise will be rejected.\n **/\nconst timeout = (fn, time, errCb) => {\n  return (...args) => {\n    return new Promise((resolve, reject) => {\n      const timer = setTimeout(() => {\n        if (errCb) reject(errCb(...args));\n        else {\n          reject(new Error('Function timed out'));\n        }\n      }, time);\n      // Wrap fn call in Promise.resolve to handle both sync and async functions\n      Promise.resolve(fn(...args))\n        .then((result) => {\n          clearTimeout(timer);\n          resolve(result);\n        })\n        .catch((err) => {\n          clearTimeout(timer);\n          reject(err);\n        });\n    });\n  };\n};\nexport default timeout;\n"
    },
    "category": "functional",
    "type": "functions"
  },
  {
    "name": "tryCatch",
    "code": {
      "ts": "/**\n * Helps to safely execute synchronous functions\n **/\ntype TryCatchReturn<Err, Return> = [Err, undefined] | [undefined, Return];\n\nconst tryCatch = <Err extends Error, Return>(\n  fn: () => Return,\n): TryCatchReturn<Err, Return> => {\n  let data: Return | undefined = undefined;\n  let err: Err | undefined = undefined;\n\n  try {\n    data = fn();\n  } catch (error) {\n    err = error as Err;\n  }\n  return [err, data] as TryCatchReturn<Err, Return>;\n};\n\nexport default tryCatch;\n",
      "js": "const tryCatch = (fn) => {\n  let data = undefined;\n  let err = undefined;\n  try {\n    data = fn();\n  } catch (error) {\n    err = error;\n  }\n  return [err, data];\n};\nexport default tryCatch;\n"
    },
    "category": "functional",
    "type": "functions"
  },
  {
    "name": "tryCatchAsync",
    "code": {
      "ts": "/**\n * Helps to safely execute asynchronous functions\n **/\n\ntype TryCatchReturnAsync<Err, Return> = Promise<\n  [Err, undefined] | [undefined, Return]\n>;\n\nconst tryCatchAsync = async <Err extends Error, Return>(\n  fn: () => Promise<Return>,\n): TryCatchReturnAsync<Err, Return> => {\n  try {\n    const result = await fn();\n    return [undefined, result] as [undefined, Return];\n  } catch (error) {\n    return [error as Err, undefined] as [Err, undefined];\n  }\n};\n\nexport default tryCatchAsync;\n",
      "js": "/**\n * Helps to safely execute asynchronous functions\n **/\nconst tryCatchAsync = async (fn) => {\n  try {\n    const result = await fn();\n    return [undefined, result];\n  } catch (error) {\n    return [error, undefined];\n  }\n};\nexport default tryCatchAsync;\n"
    },
    "category": "functional",
    "type": "functions"
  },
  {
    "name": "unique",
    "code": {
      "ts": "/**\n * Creates a unique array from the input array.\n **/\nconst unique = <T,>(arr: T[]): T[] => {\n  return [...new Set(arr)];\n};\n\nexport default unique;\n",
      "js": "/**\n * Creates a unique array from the input array.\n **/\nconst unique = (arr) => {\n  return [...new Set(arr)];\n};\nexport default unique;\n"
    },
    "category": "arrays",
    "type": "functions"
  },
  {
    "name": "useBoolean",
    "code": {
      "ts": "/**\n * hook for managing a boolean state, providing easy functions to set the state to true, false, or toggle its value.\n **/\nimport { useCallback, useState } from 'react';\n\nimport type { Dispatch, SetStateAction } from 'react';\n\ntype UseBooleanReturn = {\n  value: boolean;\n  setValue: Dispatch<SetStateAction<boolean>>;\n  setTrue: () => void;\n  setFalse: () => void;\n  toggle: () => void;\n};\n\nconst useBoolean = (defaultValue = false): UseBooleanReturn => {\n  if (typeof defaultValue !== 'boolean') {\n    throw new Error('defaultValue must be `true` or `false`');\n  }\n\n  const [value, setValue] = useState(defaultValue);\n\n  const setTrue = useCallback(() => {\n    setValue(true);\n  }, []);\n\n  const setFalse = useCallback(() => {\n    setValue(false);\n  }, []);\n\n  const toggle = useCallback(() => {\n    setValue((x) => !x);\n  }, []);\n\n  return { value, setValue, setTrue, setFalse, toggle };\n};\n\nexport default useBoolean;\n",
      "js": "/**\n * hook for managing a boolean state, providing easy functions to set the state to true, false, or toggle its value.\n **/\nimport { useCallback, useState } from 'react';\nconst useBoolean = (defaultValue = false) => {\n  if (typeof defaultValue !== 'boolean') {\n    throw new Error('defaultValue must be `true` or `false`');\n  }\n  const [value, setValue] = useState(defaultValue);\n  const setTrue = useCallback(() => {\n    setValue(true);\n  }, []);\n  const setFalse = useCallback(() => {\n    setValue(false);\n  }, []);\n  const toggle = useCallback(() => {\n    setValue((x) => !x);\n  }, []);\n  return { value, setValue, setTrue, setFalse, toggle };\n};\nexport default useBoolean;\n"
    },
    "category": "boolean",
    "type": "react-hooks"
  },
  {
    "name": "zip",
    "code": {
      "ts": "/**\n * Zips arrays together in the form of an array of arrays.\n **/\ntype Args<T extends Array<Array<unknown>>> = {\n  arr: T;\n  strict?: boolean;\n};\n\nconst zip = <T extends Array<Array<unknown>>>({\n  arr,\n  strict = false,\n}: Args<T>): T => {\n  const maxIndex = arr.map((a) => a.length).reduce((a, b) => Math.max(a, b), 0);\n  const minIndex = arr\n    .map((a) => a.length)\n    .reduce((a, b) => Math.min(a, b), maxIndex);\n\n  let result = [] as unknown[][];\n\n  const upto = strict ? minIndex : maxIndex;\n\n  for (let i = 0; i < upto; i++) {\n    const zip = arr.map((a) => a[i]);\n    result.push(zip);\n  }\n\n  return result as T;\n};\n\nexport default zip;\n",
      "js": "const zip = ({ arr, strict = false }) => {\n  const maxIndex = arr.map((a) => a.length).reduce((a, b) => Math.max(a, b), 0);\n  const minIndex = arr\n    .map((a) => a.length)\n    .reduce((a, b) => Math.min(a, b), maxIndex);\n  let result = [];\n  const upto = strict ? minIndex : maxIndex;\n  for (let i = 0; i < upto; i++) {\n    const zip = arr.map((a) => a[i]);\n    result.push(zip);\n  }\n  return result;\n};\nexport default zip;\n"
    },
    "category": "arrays",
    "type": "functions"
  }
]