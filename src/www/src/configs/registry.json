[
  {
    "name": "compact",
    "code": {
      "ts": "/**\r\n * Removes falsy values\r\n * Also removes empty objects and arrays if strict is true\r\n *\r\n * @template T - The type of elements in the array.\r\n * @param {T[]} array - The array to compact.\r\n * @param {boolean} [strict=false] - If true, also removes empty objects and arrays.\r\n * @returns {T[]} - The compacted array.\r\n */\r\nconst compact = <T>(array: T[], strict: boolean = false): T[] => {\r\n  let truthy = array.filter((item) => {\r\n    // remove all falsy values and excluded values\r\n    return Boolean(item);\r\n  });\r\n\r\n  if (strict) {\r\n    // remove all empty objects\r\n    truthy = truthy.filter((item) => {\r\n      if (typeof item === \"object\" && !(item instanceof Array)) {\r\n        return Object.keys(item as object).length > 0;\r\n      }\r\n      return true;\r\n    });\r\n    // remove all empty arrays\r\n    truthy = truthy.filter((item) => {\r\n      if (Array.isArray(item)) {\r\n        return (item as []).length > 0;\r\n      }\r\n      return true;\r\n    });\r\n  }\r\n  return truthy;\r\n};\r\n\r\nexport default compact;\r\n",
      "js": "/**\n * Removes falsy values\n * Also removes empty objects and arrays if strict is true\n *\n * @template T - The type of elements in the array.\n * @param {T[]} array - The array to compact.\n * @param {boolean} [strict=false] - If true, also removes empty objects and arrays.\n * @returns {T[]} - The compacted array.\n */\nconst compact = (array, strict = false) => {\n    let truthy = array.filter((item) => {\n        // remove all falsy values and excluded values\n        return Boolean(item);\n    });\n    if (strict) {\n        // remove all empty objects\n        truthy = truthy.filter((item) => {\n            if (typeof item === \"object\" && !(item instanceof Array)) {\n                return Object.keys(item).length > 0;\n            }\n            return true;\n        });\n        // remove all empty arrays\n        truthy = truthy.filter((item) => {\n            if (Array.isArray(item)) {\n                return item.length > 0;\n            }\n            return true;\n        });\n    }\n    return truthy;\n};\nexport default compact;\n"
    },
    "category": "arrays",
    "type": "functions",
    "examples": [
      "import compact from \".\";\r\n\r\nconst input = [0, false, \"\", null, undefined, NaN, {}, [], 1, \"hello\"];\r\n\r\n// no strict mode\r\nconst result = compact(input);\r\nconsole.log(result);\r\n// Expected output: [{}, [], 1, \"hello\"]\r\n\r\n// strict mode\r\nconst resultStrict = compact(input, true);\r\nconsole.log(resultStrict);\r\n// Expected output: [1, \"hello\"]\r\n"
    ],
    "createdAt": {
      "date": "2024-04-13T14:39:39.185Z",
      "packageVersion": "0.1.0"
    },
    "lastUpdated": {
      "date": "2024-04-13T14:39:39.185Z",
      "packageVersion": "0.1.0"
    }
  },
  {
    "name": "chunk",
    "code": {
      "ts": "/**\r\n * Splits an array into chunks of a specified size.\r\n *\r\n * @template T - The type of elements in the array.\r\n * @param {T[]} array - The array to be chunked.\r\n * @param {number} [size=1] - The size of each chunk.\r\n * @param {boolean} [strict=false] - Whether to remove the last chunk if it is not equal to the size.\r\n * @returns {T[][]} - An array of chunks.\r\n */\r\nconst chunk = <T>(\r\n  array: T[],\r\n  size: number = 1,\r\n  strict: boolean = false\r\n  //remove the last chunk if it is not equal to the size\r\n): T[][] => {\r\n  const result: T[][] = [];\r\n\r\n  //push the chunks into the result array\r\n  for (let i = 0; i < array.length; i += size) {\r\n    result.push(array.slice(i, i + size));\r\n  }\r\n\r\n  //remove the last chunk if it is not equal to the size\r\n  if (strict && result[result.length - 1].length !== size) {\r\n    result.pop();\r\n  }\r\n  return result;\r\n};\r\n\r\nexport default chunk;\r\n",
      "js": "/**\n * Splits an array into chunks of a specified size.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} array - The array to be chunked.\n * @param {number} [size=1] - The size of each chunk.\n * @param {boolean} [strict=false] - Whether to remove the last chunk if it is not equal to the size.\n * @returns {T[][]} - An array of chunks.\n */\nconst chunk = (array, size = 1, strict = false\n//remove the last chunk if it is not equal to the size\n) => {\n    const result = [];\n    //push the chunks into the result array\n    for (let i = 0; i < array.length; i += size) {\n        result.push(array.slice(i, i + size));\n    }\n    //remove the last chunk if it is not equal to the size\n    if (strict && result[result.length - 1].length !== size) {\n        result.pop();\n    }\n    return result;\n};\nexport default chunk;\n"
    },
    "category": "arrays",
    "type": "functions",
    "examples": [
      "import chunk from \".\";\r\n\r\nconst arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\r\n\r\n// No size provided, default size is 1\r\nconsole.log(chunk(arr));\r\n// Expected output: [[1], [2], [3], [4], [5], [6], [7], [8], [9], [10]];\r\n\r\n// Providing size as 2\r\nconsole.log(chunk(arr, 2));\r\n// Expected output: [ [ 1, 2 ], [ 3, 4 ], [ 5, 6 ], [ 7, 8 ], [ 9, 10 ] ]\r\n\r\n// Providing size as 3 and strict as true\r\nconsole.log(chunk(arr, 3, true));\r\n// Expected output: [ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ] ]\r\n\r\n// Providing size as 4 and strict as true\r\nconsole.log(chunk(arr, 4, true));\r\n// Expected output: [ [ 1, 2, 3, 4 ], [ 5, 6, 7, 8 ] ]\r\n"
    ],
    "createdAt": {
      "date": "2024-04-13T14:39:39.130Z",
      "packageVersion": "0.1.0"
    },
    "lastUpdated": {
      "date": "2024-04-13T14:39:39.132Z",
      "packageVersion": "0.1.0"
    }
  },
  {
    "name": "insert",
    "code": {
      "ts": "/**\r\n * Inserts elements into an array at a specified index.\r\n *\r\n * @template T - The type of elements in the array.\r\n * @param {T[]} arr - The array to insert elements into.\r\n * @param {number} index - The index at which to insert the elements.\r\n * @param {boolean} [recursive=false] - Indicates whether to insert elements recursively. If true, the elements will be inserted at every nth index.\r\n * @param {...T[]} items - The elements to insert into the array.\r\n * @returns {T[]} - The modified array with the inserted elements.\r\n */\r\nconst insert = <T>(\r\n  arr: T[],\r\n  index: number,\r\n  [...items]: T[],\r\n  recursive: boolean = false\r\n): T[] => {\r\n  const isNegativeIndex = index < 0;\r\n  // if index is negative, convert it to positive and reverse the array for easier insertion\r\n  if (isNegativeIndex) {\r\n    index = Math.abs(index);\r\n    arr = arr.reverse();\r\n    items = items.reverse();\r\n  }\r\n\r\n  if (!recursive) {\r\n    const newArr = [...arr.slice(0, index), ...items, ...arr.slice(index)];\r\n    return isNegativeIndex ? newArr.reverse() : newArr;\r\n  } else {\r\n    const shouldInsert = Math.floor(arr.length / index);\r\n    let newArr = [...arr];\r\n    for (let i = 0; i < shouldInsert; i++) {\r\n      const insertIndex = (i + 1) * index + i * items.length;\r\n      newArr = [\r\n        ...newArr.slice(0, insertIndex),\r\n        ...items,\r\n        ...newArr.slice(insertIndex),\r\n      ];\r\n    }\r\n    return isNegativeIndex ? newArr.reverse() : newArr;\r\n  }\r\n};\r\n\r\nexport default insert;\r\n",
      "js": "/**\n * Inserts elements into an array at a specified index.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} arr - The array to insert elements into.\n * @param {number} index - The index at which to insert the elements.\n * @param {boolean} [recursive=false] - Indicates whether to insert elements recursively. If true, the elements will be inserted at every nth index.\n * @param {...T[]} items - The elements to insert into the array.\n * @returns {T[]} - The modified array with the inserted elements.\n */\nconst insert = (arr, index, [...items], recursive = false) => {\n    const isNegativeIndex = index < 0;\n    // if index is negative, convert it to positive and reverse the array for easier insertion\n    if (isNegativeIndex) {\n        index = Math.abs(index);\n        arr = arr.reverse();\n        items = items.reverse();\n    }\n    if (!recursive) {\n        const newArr = [...arr.slice(0, index), ...items, ...arr.slice(index)];\n        return isNegativeIndex ? newArr.reverse() : newArr;\n    }\n    else {\n        const shouldInsert = Math.floor(arr.length / index);\n        let newArr = [...arr];\n        for (let i = 0; i < shouldInsert; i++) {\n            const insertIndex = (i + 1) * index + i * items.length;\n            newArr = [\n                ...newArr.slice(0, insertIndex),\n                ...items,\n                ...newArr.slice(insertIndex),\n            ];\n        }\n        return isNegativeIndex ? newArr.reverse() : newArr;\n    }\n};\nexport default insert;\n"
    },
    "category": "arrays",
    "type": "functions",
    "examples": [
      "import insert from \".\";\r\n\r\nconst arr = [1, 2, 3];\r\nconst index = 1;\r\nconst items = [4, 5];\r\n\r\nconst result = insert(arr, index, items);\r\nconsole.log(result);\r\n// Expected Output: [1, 4, 5, 2, 3]\r\n\r\nconst arr2 = [1, 2, 3, 4, 5];\r\nconst index2 = 2;\r\nconst items2 = [6, 7];\r\n\r\nconst result2 = insert(arr2, index2, items2);\r\nconsole.log(result2);\r\n// Expected Output: [1, 2, 6, 7, 3, 4, 5 ]\r\n\r\n// negative index\r\nconst arr3 = [1, 2, 3];\r\nconst index3 = -1;\r\nconst items3 = [4, 5];\r\n\r\nconst result3 = insert(arr3, index3, items3);\r\nconsole.log(result3);\r\n// Expected Output: [1, 2, 4, 5, 3]\r\n",
      "//recursive examples\r\n\r\nimport insert from \".\";\r\n\r\nconst arr = [1, 2, 3];\r\nconst index = 1;\r\nconst items = [4, 5];\r\n\r\nconst result = insert(arr, index, items, true);\r\nconsole.log(result);\r\n// Expected Output: [1, 4, 5, 2, 4, 5, 3, 4, 5]\r\n\r\nconst arr2 = [1, 2, 3, 4, 5];\r\nconst index2 = 2;\r\nconst items2 = [6, 7];\r\n\r\nconst result2 = insert(arr2, index2, items2, true);\r\nconsole.log(result2);\r\n// Expected Output: [1, 2, 6, 7, 3, 4, 6, 7, 5]\r\n\r\n//negative index\r\n\r\nconst arr3 = [1, 2, 3];\r\nconst index3 = -1;\r\nconst items3 = [4, 5];\r\n\r\nconst result3 = insert(arr3, index3, items3, true);\r\nconsole.log(result3);\r\n// Expected Output: [4, 5, 1, 4, 5, 2, 4, 5, 3]\r\n"
    ],
    "createdAt": {
      "date": "2024-04-13T18:26:09.144Z",
      "packageVersion": "0.1.0"
    },
    "lastUpdated": {
      "date": "2024-04-13T18:26:09.145Z",
      "packageVersion": "0.1.0"
    }
  },
  {
    "name": "sampleArr",
    "code": {
      "ts": "/**\r\n * Generates an array of random numbers.\r\n *\r\n * @param size - The size of the array to generate.\r\n * @returns An array of random numbers.\r\n * @throws {Error} If the size is a negative number.\r\n */\r\nconst sampleArr = (size: number) => {\r\n  if (size < 0) throw new Error(\"Size must be a positive number\");\r\n  return Array.from({ length: size }, (_, i) => Math.floor(Math.random() * i));\r\n};\r\n\r\nexport default sampleArr;\r\n",
      "js": "/**\n * Generates an array of random numbers.\n *\n * @param size - The size of the array to generate.\n * @returns An array of random numbers.\n * @throws {Error} If the size is a negative number.\n */\nconst sampleArr = (size) => {\n    if (size < 0)\n        throw new Error(\"Size must be a positive number\");\n    return Array.from({ length: size }, (_, i) => Math.floor(Math.random() * i));\n};\nexport default sampleArr;\n"
    },
    "category": "arrays",
    "type": "functions",
    "examples": [
      "import sampleArr from \".\";\r\n\r\nconst arr = sampleArr(5);\r\nconsole.log(arr);\r\n// Expected output: an array of 5 random numbers\r\n\r\n// const negativeArr = sampleArr(-1);\r\n// Expected output: Throws an error\r\n"
    ],
    "createdAt": {
      "date": "2024-04-13T15:41:54.551Z",
      "packageVersion": "0.1.0"
    },
    "lastUpdated": {
      "date": "2024-04-13T15:41:54.553Z",
      "packageVersion": "0.1.0"
    }
  },
  {
    "name": "search",
    "code": {
      "ts": "/**\r\n * Searches an array of objects based on a query string and specified keys.\r\n *\r\n * @template T - The type of objects in the array.\r\n * @param {T[]} array - The array of objects to search.\r\n * @param {string} queryString - The query string to search for.\r\n * @param {(keyof T)[] | string[]} keys - The keys to search within each object.\r\n * @returns {T[]} - The filtered array of objects that match the search criteria.\r\n */\r\nconst search = <T extends Record<string, unknown>>(\r\n  array: T[],\r\n  queryString: string,\r\n  keys: (keyof T)[] | string[]\r\n): T[] => {\r\n  // Check if the query string or keys are empty, return empty array if true\r\n  try {\r\n    if (keys.length === 0) {\r\n      return []; // Return empty array if no keys are provided\r\n    }\r\n\r\n    if (!queryString.trim()) {\r\n      return array; // Return the original array if the query string is empty\r\n    }\r\n\r\n    // Loop through the array to filter objects\r\n    const filteredArray = array.filter((obj) => {\r\n      // Loop through the keys of each object\r\n      for (let key of keys) {\r\n        // Convert the value to string only for the comparison\r\n\r\n        let value = obj[key] as any;\r\n\r\n        if (typeof value !== \"string\" && typeof value !== \"number\") {\r\n          continue; // Skip the key if it is not a string or number\r\n        }\r\n        if (typeof value === \"number\") {\r\n          value = value.toString();\r\n        }\r\n        value = value.toLowerCase();\r\n        if (value.includes(queryString.toLowerCase()?.trim())) {\r\n          return true;\r\n        }\r\n      }\r\n      // Return false if none of the keys contain the query string\r\n      return false;\r\n    });\r\n\r\n    // Return the filtered array\r\n    return filteredArray;\r\n  } catch (error) {\r\n    return [];\r\n  }\r\n};\r\n\r\nexport default search;\r\n",
      "js": "/**\n * Searches an array of objects based on a query string and specified keys.\n *\n * @template T - The type of objects in the array.\n * @param {T[]} array - The array of objects to search.\n * @param {string} queryString - The query string to search for.\n * @param {(keyof T)[] | string[]} keys - The keys to search within each object.\n * @returns {T[]} - The filtered array of objects that match the search criteria.\n */\nconst search = (array, queryString, keys) => {\n    // Check if the query string or keys are empty, return empty array if true\n    try {\n        if (keys.length === 0) {\n            return []; // Return empty array if no keys are provided\n        }\n        if (!queryString.trim()) {\n            return array; // Return the original array if the query string is empty\n        }\n        // Loop through the array to filter objects\n        const filteredArray = array.filter((obj) => {\n            // Loop through the keys of each object\n            for (let key of keys) {\n                // Convert the value to string only for the comparison\n                let value = obj[key];\n                if (typeof value !== \"string\" && typeof value !== \"number\") {\n                    continue; // Skip the key if it is not a string or number\n                }\n                if (typeof value === \"number\") {\n                    value = value.toString();\n                }\n                value = value.toLowerCase();\n                if (value.includes(queryString.toLowerCase()?.trim())) {\n                    return true;\n                }\n            }\n            // Return false if none of the keys contain the query string\n            return false;\n        });\n        // Return the filtered array\n        return filteredArray;\n    }\n    catch (error) {\n        return [];\n    }\n};\nexport default search;\n"
    },
    "category": "arrays",
    "type": "functions",
    "examples": [
      "import search from \".\";\r\n\r\nconst array = [\r\n  { name: \"John\", age: 25 },\r\n  { name: \"Jane\", age: 30 },\r\n  { name: \"John Doe\", age: 35 },\r\n];\r\n\r\n// No keys provided\r\nconsole.log(search(array, \"John\", []));\r\n// Expected output: []\r\n\r\n// Query string is empty\r\nconsole.log(search(array, \"\", [\"name\"]));\r\n// Expected output: [ { name: 'John', age: 25 }, { name: 'Jane', age: 30 }, { name: 'John Doe', age: 35 } ]\r\n\r\n// Filtered array of objects matching the query\r\nconsole.log(search(array, \"John\", [\"name\"]));\r\n// Expected output: [ { name: 'John', age: 25 }, { name: 'John Doe', age: 35 } ]\r\n\r\n// None of the keys contain the query string\r\nconsole.log(search(array, \"Doe\", [\"name\"]));\r\n// Expected output: []\r\n\r\n// Keys does not exist in the object\r\nconsole.log(search(array, \"John\", [\"email\"]));\r\n// Expected output: []\r\n"
    ],
    "createdAt": {
      "date": "2024-04-13T14:39:39.226Z",
      "packageVersion": "0.1.0"
    },
    "lastUpdated": {
      "date": "2024-04-13T14:39:39.226Z",
      "packageVersion": "0.1.0"
    }
  },
  {
    "name": "shuffleArr",
    "code": {
      "ts": "const shuffleArr = <T>(arr: T[]) => {\r\n  const copy = [...arr];\r\n  for (let i = copy.length - 1; i > 0; i--) {\r\n    const j = Math.floor(Math.random() * (i + 1));\r\n    [copy[i], copy[j]] = [copy[j], copy[i]];\r\n  }\r\n  \r\n  return copy;\r\n};\r\n\r\nexport default shuffleArr;\r\n",
      "js": "const shuffleArr = (arr) => {\n    const copy = [...arr];\n    for (let i = copy.length - 1; i > 0; i--) {\n        const j = Math.floor(Math.random() * (i + 1));\n        [copy[i], copy[j]] = [copy[j], copy[i]];\n    }\n    return copy;\n};\nexport default shuffleArr;\n"
    },
    "category": "arrays",
    "type": "functions",
    "examples": [
      "import shuffleArr from \".\";\r\n\r\nconst arr = [1, 2, 3, 4, 5];\r\nconst shuffledArr = shuffleArr(arr);\r\nconsole.log(shuffledArr);\r\n// Expected output: shuffled array of given array\r\n"
    ],
    "createdAt": {
      "date": "2024-04-13T15:50:52.166Z",
      "packageVersion": "0.1.0"
    },
    "lastUpdated": {
      "date": "2024-04-13T15:50:52.167Z",
      "packageVersion": "0.1.0"
    }
  },
  {
    "name": "unique",
    "code": {
      "ts": "/**\r\n * Returns an array with unique elements from the input array.\r\n *\r\n * @template T - The type of elements in the array.\r\n * @param {T[]} arr - The input array.\r\n * @returns {T[]} - An array with unique elements.\r\n */\r\nconst unique = <T>(arr: T[]): T[] => {\r\n  //@ts-ignore\r\n  return [...new Set(arr)];\r\n};\r\n\r\nexport default unique;\r\n",
      "js": "/**\n * Returns an array with unique elements from the input array.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} arr - The input array.\n * @returns {T[]} - An array with unique elements.\n */\nconst unique = (arr) => {\n    //@ts-ignore\n    return [...new Set(arr)];\n};\nexport default unique;\n"
    },
    "category": "arrays",
    "type": "functions",
    "examples": [
      "import unique from \".\";\r\n\r\nconst arr = [1, 2, 3, 3, 4, 5, 5, 6, 7, 8, 8, 9, 10];\r\nconst result = unique(arr);\r\nconsole.log(result);\r\n// Expected Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\r\n"
    ],
    "createdAt": {
      "date": "2024-04-13T18:45:24.667Z",
      "packageVersion": "0.1.0"
    },
    "lastUpdated": {
      "date": "2024-04-13T18:45:24.668Z",
      "packageVersion": "0.1.0"
    }
  },
  {
    "name": "retry",
    "code": {
      "ts": "/**\r\n * Retries the given function a specified number of times with a delay between each retry.\r\n * @param fn The function to retry.\r\n * @param retries The number of times to retry the function. Default is 3.\r\n * @param delay The delay in milliseconds between each retry. Default is 1000ms (1 second).\r\n * @returns A Promise that resolves to the result of the function if it succeeds, or rejects with the last error if all retries fail.\r\n */\r\nconst retry = async <T>(\r\n  fn: Function,\r\n  retries: number = 3,\r\n  delay: number = 1000\r\n): Promise<T> => {\r\n  try {\r\n    return await fn();\r\n  } catch (error) {\r\n    if (retries > 0) {\r\n      await new Promise((resolve) => setTimeout(resolve, delay));\r\n      return retry(fn, retries - 1, delay);\r\n    }\r\n    throw error;\r\n  }\r\n};\r\n\r\nexport default retry;\r\n",
      "js": "/**\n * Retries the given function a specified number of times with a delay between each retry.\n * @param fn The function to retry.\n * @param retries The number of times to retry the function. Default is 3.\n * @param delay The delay in milliseconds between each retry. Default is 1000ms (1 second).\n * @returns A Promise that resolves to the result of the function if it succeeds, or rejects with the last error if all retries fail.\n */\nconst retry = async (fn, retries = 3, delay = 1000) => {\n    try {\n        return await fn();\n    }\n    catch (error) {\n        if (retries > 0) {\n            await new Promise((resolve) => setTimeout(resolve, delay));\n            return retry(fn, retries - 1, delay);\n        }\n        throw error;\n    }\n};\nexport default retry;\n"
    },
    "category": "functional",
    "type": "functions",
    "examples": [
      "import retry from \".\";\r\n\r\nconst fn = async () => {\r\n  Promise.reject(new Error(\"failed\"));\r\n};\r\n\r\nretry(fn, 2, 1000).catch((error) => {\r\n  console.log(error.message);\r\n});\r\n// Expected output: \"failed\" after retrying twice but It will call the function 3 times.\r\n"
    ],
    "createdAt": {
      "date": "2024-04-15T12:21:49.769Z",
      "packageVersion": "0.1.0"
    },
    "lastUpdated": {
      "date": "2024-04-15T12:21:49.770Z",
      "packageVersion": "0.1.0"
    }
  },
  {
    "name": "timeout",
    "code": {
      "ts": "/**\r\n * Wraps a function with a timeout.\r\n * If the function does not complete within the specified time, the promise will be rejected.\r\n *\r\n * @template Return - The return type of the wrapped function.\r\n * @template Err - The error type that can be thrown by the wrapped function or the error callback.\r\n * @param {(...args: any[]) => Return} fn - The function to be wrapped.\r\n * @param {number} time - The timeout duration in milliseconds.\r\n * @param {(...args: any[]) => Err} [errCb] - Optional error callback function to handle timeout errors.\r\n * @returns {(...args: any[]) => Promise<Return>} - A wrapped function that returns a promise.\r\n */\r\nconst timeout = <Return, Err>(\r\n  fn: (...args: any[]) => Return,\r\n  time: number,\r\n  errCb?: (...args: any[]) => Err\r\n): ((...args: any[]) => Promise<Return>) => {\r\n  return (...args: any[]) => {\r\n    return new Promise<any>((resolve, reject) => {\r\n      const timer = setTimeout(() => {\r\n        if (errCb) reject(errCb(...args));\r\n        else {\r\n          reject(new Error(\"Function timed out\"));\r\n        }\r\n      }, time);\r\n\r\n      // Wrap fn call in Promise.resolve to handle both sync and async functions\r\n      Promise.resolve(fn(...args))\r\n        .then((result: Return) => {\r\n          clearTimeout(timer);\r\n          resolve(result);\r\n        })\r\n        .catch((err: Err) => {\r\n          clearTimeout(timer);\r\n          reject(err);\r\n        });\r\n    });\r\n  };\r\n};\r\n\r\nexport default timeout;\r\n",
      "js": "/**\n * Wraps a function with a timeout.\n * If the function does not complete within the specified time, the promise will be rejected.\n *\n * @template Return - The return type of the wrapped function.\n * @template Err - The error type that can be thrown by the wrapped function or the error callback.\n * @param {(...args: any[]) => Return} fn - The function to be wrapped.\n * @param {number} time - The timeout duration in milliseconds.\n * @param {(...args: any[]) => Err} [errCb] - Optional error callback function to handle timeout errors.\n * @returns {(...args: any[]) => Promise<Return>} - A wrapped function that returns a promise.\n */\nconst timeout = (fn, time, errCb) => {\n    return (...args) => {\n        return new Promise((resolve, reject) => {\n            const timer = setTimeout(() => {\n                if (errCb)\n                    reject(errCb(...args));\n                else {\n                    reject(new Error(\"Function timed out\"));\n                }\n            }, time);\n            // Wrap fn call in Promise.resolve to handle both sync and async functions\n            Promise.resolve(fn(...args))\n                .then((result) => {\n                clearTimeout(timer);\n                resolve(result);\n            })\n                .catch((err) => {\n                clearTimeout(timer);\n                reject(err);\n            });\n        });\n    };\n};\nexport default timeout;\n"
    },
    "category": "functional",
    "type": "functions",
    "examples": [
      "import timeout from \".\";\r\n\r\ntimeout(() => \"Hello, World!\", 1000);\r\n// Expected Output: \"Hello, World!\"\r\n\r\ntimeout(() => new Promise((resolve) => setTimeout(resolve, 2000)), 1000);\r\n// Expected Output: Error: Function timed out\r\n\r\ntimeout(\r\n  () => new Promise((resolve) => setTimeout(resolve, 2000)),\r\n  1000,\r\n  () => console.log(\"I failed\")\r\n);\r\n// Expected Output: I failed\r\n"
    ],
    "createdAt": {
      "date": "2024-04-13T19:42:32.421Z",
      "packageVersion": "0.1.0"
    },
    "lastUpdated": {
      "date": "2024-04-13T19:42:32.423Z",
      "packageVersion": "0.1.0"
    }
  },
  {
    "name": "and",
    "code": {
      "ts": "/**\r\n * Performs a logical AND operation on the given boolean values.\r\n * Returns true if all arguments are true, otherwise returns false.\r\n *\r\n * @param args - The boolean values to perform the AND operation on.\r\n * @returns The result of the logical AND operation.\r\n */\r\nconst and = (...args: any[]) => {\r\n  if (args.length === 0) return false;\r\n  return args.every((arg) => Boolean(arg));\r\n};\r\n\r\nexport default and;\r\n",
      "js": "/**\n * Performs a logical AND operation on the given boolean values.\n * Returns true if all arguments are true, otherwise returns false.\n *\n * @param args - The boolean values to perform the AND operation on.\n * @returns The result of the logical AND operation.\n */\nconst and = (...args) => {\n    if (args.length === 0)\n        return false;\n    return args.every((arg) => Boolean(arg));\n};\nexport default and;\n"
    },
    "category": "gates",
    "type": "functions",
    "examples": [
      "import and from \".\";\r\n\r\nconsole.log(and(true, true));\r\n// Expected Output: true\r\n\r\nconsole.log(and(true, false));\r\n// Expected Output: false\r\n\r\nconsole.log(and());\r\n// Expected Output: true\r\n\r\nconsole.log(and(1, \"lazykit\"));\r\n// Expected Output: true\r\n"
    ],
    "createdAt": {
      "date": "2024-04-13T14:39:39.237Z",
      "packageVersion": "0.1.0"
    },
    "lastUpdated": {
      "date": "2024-04-13T14:39:39.237Z",
      "packageVersion": "0.1.0"
    }
  },
  {
    "name": "nand",
    "code": {
      "ts": "/**\r\n * Performs a NAND (NOT AND) operation on the given arguments.\r\n * Returns `false` if no arguments are provided or if all arguments are truthy.\r\n * Returns `true` if any argument is falsy.\r\n *\r\n * @param args - The arguments to perform the NAND operation on.\r\n * @returns The result of the NAND operation.\r\n */\r\nconst nand = (...args: any[]) => {\r\n  if (args.length === 0) return false;\r\n  const and = args.every((arg) => Boolean(arg));\r\n  return !and;\r\n};\r\n\r\nexport default nand;\r\n",
      "js": "/**\n * Performs a NAND (NOT AND) operation on the given arguments.\n * Returns `false` if no arguments are provided or if all arguments are truthy.\n * Returns `true` if any argument is falsy.\n *\n * @param args - The arguments to perform the NAND operation on.\n * @returns The result of the NAND operation.\n */\nconst nand = (...args) => {\n    if (args.length === 0)\n        return false;\n    const and = args.every((arg) => Boolean(arg));\n    return !and;\n};\nexport default nand;\n"
    },
    "category": "gates",
    "type": "functions",
    "examples": [
      "import nand from \".\";\r\n\r\nconsole.log(nand(true, true));\r\n// Expected Output: false\r\n\r\nconsole.log(nand(true, false));\r\n// Expected Output: true\r\n\r\nconsole.log(nand());\r\n// Expected Output: false\r\n\r\nconsole.log(nand(1, \"lazykit\"));\r\n// Expected Output: false\r\n"
    ],
    "createdAt": {
      "date": "2024-04-13T14:39:39.250Z",
      "packageVersion": "0.1.0"
    },
    "lastUpdated": {
      "date": "2024-04-13T14:39:39.250Z",
      "packageVersion": "0.1.0"
    }
  },
  {
    "name": "nor",
    "code": {
      "ts": "/**\r\n * Performs a logical NOR operation on the given arguments.\r\n * Returns true if none of the arguments are truthy, otherwise returns false.\r\n *\r\n * @param args - The arguments to perform the NOR operation on.\r\n * @returns The result of the NOR operation.\r\n */\r\nconst nor = (...args: any[]) => {\r\n  if (args.length === 0) return false;\r\n  const or = args.some((arg) => Boolean(arg));\r\n  return !or;\r\n};\r\n\r\nexport default nor;\r\n",
      "js": "/**\n * Performs a logical NOR operation on the given arguments.\n * Returns true if none of the arguments are truthy, otherwise returns false.\n *\n * @param args - The arguments to perform the NOR operation on.\n * @returns The result of the NOR operation.\n */\nconst nor = (...args) => {\n    if (args.length === 0)\n        return false;\n    const or = args.some((arg) => Boolean(arg));\n    return !or;\n};\nexport default nor;\n"
    },
    "category": "gates",
    "type": "functions",
    "examples": [
      "import or from \".\";\r\n\r\nconsole.log(or(true, true));\r\n// Expected Output: false\r\n\r\nconsole.log(or(false, true));\r\n// Expected Output: false\r\n\r\nconsole.log(or(false, false));\r\n// Expected Output: true\r\n\r\nconsole.log(or());\r\n// Expected Output: true\r\n\r\nconsole.log(or(1, \"lazykit\"));\r\n// Expected Output: false\r\n"
    ],
    "createdAt": {
      "date": "2024-04-13T14:39:39.165Z",
      "packageVersion": "0.1.0"
    },
    "lastUpdated": {
      "date": "2024-04-13T14:39:39.165Z",
      "packageVersion": "0.1.0"
    }
  },
  {
    "name": "or",
    "code": {
      "ts": "/**\r\n * Performs a logical OR operation on the given arguments.\r\n *\r\n * @param args - The arguments to perform the OR operation on.\r\n * @returns The result of the OR operation.\r\n */\r\nconst or = (...args: any[]) => {\r\n  return args.some((arg) => Boolean(arg));\r\n};\r\n\r\nexport default or;\r\n",
      "js": "/**\n * Performs a logical OR operation on the given arguments.\n *\n * @param args - The arguments to perform the OR operation on.\n * @returns The result of the OR operation.\n */\nconst or = (...args) => {\n    return args.some((arg) => Boolean(arg));\n};\nexport default or;\n"
    },
    "category": "gates",
    "type": "functions",
    "examples": [
      "import or from \".\";\r\n\r\nconsole.log(or(true, true));\r\n// Expected Output: true\r\n\r\nconsole.log(or(false, true));\r\n// Expected Output: true\r\n\r\nconsole.log(or(false, false));\r\n// Expected Output: false\r\n\r\nconsole.log(or());\r\n// Expected Output: false\r\n\r\nconsole.log(or(1, \"lazykit\"));\r\n// Expected Output: true\r\n"
    ],
    "createdAt": {
      "date": "2024-04-13T14:39:39.259Z",
      "packageVersion": "0.1.0"
    },
    "lastUpdated": {
      "date": "2024-04-13T14:39:39.259Z",
      "packageVersion": "0.1.0"
    }
  },
  {
    "name": "mapObj",
    "code": {
      "ts": "/**\r\n * Maps over the properties of an object and applies a callback function to each property.\r\n *\r\n * @template T - The type of the values in the input object.\r\n * @template U - The type of the values in the output object.\r\n * @param {Record<string, T>} obj - The input object.\r\n * @param {(value: T, key: string, obj: Record<string, T>) => U} callback - The callback function to apply to each property.\r\n * @returns {Record<string, U>} - The resulting object with the mapped properties.\r\n */\r\n\r\nconst mapObj = <T, U>(\r\n  obj: Record<string, T>,\r\n  callback: (value: T, key: string, obj: Record<string, T>) => U\r\n): Record<string, U> => {\r\n  const result: Record<string, U> = {};\r\n\r\n  // loop through each key in the object\r\n  for (const key in obj) {\r\n    // check if the key is a property of the object\r\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\r\n      result[key] = callback(obj[key], key, obj);\r\n    }\r\n  }\r\n\r\n  return result;\r\n};\r\n\r\nexport default mapObj;\r\n",
      "js": "/**\n * Maps over the properties of an object and applies a callback function to each property.\n *\n * @template T - The type of the values in the input object.\n * @template U - The type of the values in the output object.\n * @param {Record<string, T>} obj - The input object.\n * @param {(value: T, key: string, obj: Record<string, T>) => U} callback - The callback function to apply to each property.\n * @returns {Record<string, U>} - The resulting object with the mapped properties.\n */\nconst mapObj = (obj, callback) => {\n    const result = {};\n    // loop through each key in the object\n    for (const key in obj) {\n        // check if the key is a property of the object\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            result[key] = callback(obj[key], key, obj);\n        }\n    }\n    return result;\n};\nexport default mapObj;\n"
    },
    "category": "objects",
    "type": "functions",
    "examples": [
      "import mapObj from \".\";\r\n\r\nconst obj1 = { a: 1, b: 2, c: 3 };\r\nconst result1 = mapObj(obj1, (value: number) => value * 2);\r\nconsole.log(result1);\r\n// Expected output:  { a: 2, b: 4, c: 6 }\r\n\r\nconst obj2 = {};\r\nconst result2 = mapObj(obj2, (value: any) => value);\r\nconsole.log(result2);\r\n// Expected output:  {}\r\n\r\nconst obj3 = { 1: \"one\", 2: \"two\", 3: \"three\" };\r\nconst result = mapObj(obj3, (value: string, i) => value.toUpperCase() + i);\r\nconsole.log(result);\r\n// Expected output: { 1: 'ONE1', 2: 'TWO2', 3: 'THREE3' }\r\n"
    ],
    "createdAt": {
      "date": "2024-04-13T14:39:39.287Z",
      "packageVersion": "0.1.0"
    },
    "lastUpdated": {
      "date": "2024-04-13T14:39:39.287Z",
      "packageVersion": "0.1.0"
    }
  }
]