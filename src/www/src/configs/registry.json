[
  {
    "name": "and",
    "code": {
      "ts": "const and = (...args: unknown[]) => {\n  if (args.length === 0) return false;\n  return args.every((arg) => Boolean(arg));\n};\n\nexport default and;\n",
      "js": "const and = (...args) => {\n  if (args.length === 0) return false;\n  return args.every((arg) => Boolean(arg));\n};\nexport default and;\n"
    },
    "category": "gates",
    "type": "functions",
    "props": [
      {
        "title": "args",
        "required": true,
        "propDesc": "The arguments to perform the AND operation on.",
        "type": "unknown[]"
      }
    ]
  },
  {
    "name": "callAfter",
    "code": {
      "ts": "const callAfter = <T, S extends any[]>(\n  fn: (...args: S) => T,\n  count: number,\n): ((...args: S) => T | undefined) => {\n  let counter = 0;\n  return (...args: S): T | undefined => {\n    if (counter < count) {\n      counter++;\n      return undefined;\n    }\n    return fn(...args);\n  };\n};\n\nexport default callAfter;\n",
      "js": "const callAfter = (fn, count) => {\n  let counter = 0;\n  return (...args) => {\n    if (counter < count) {\n      counter++;\n      return undefined;\n    }\n    return fn(...args);\n  };\n};\nexport default callAfter;\n"
    },
    "category": "functional",
    "type": "functions",
    "props": [
      {
        "title": "function",
        "required": true,
        "propDesc": "The function to be called",
        "type": "Function"
      },
      {
        "title": "count",
        "required": true,
        "propDesc": "The number of times the function needs to be called before it is executed",
        "type": "number"
      }
    ]
  },
  {
    "name": "callBefore",
    "code": {
      "ts": "const callBefore = <T, S extends any[]>(\n  fn: (...args: S) => T,\n  count: number,\n): ((...args: S) => T | undefined) => {\n  let counter = 0;\n  return (...args: S): T | undefined => {\n    if (counter < count) {\n      counter++;\n      return fn(...args);\n    }\n    return undefined;\n  };\n};\n\nexport default callBefore;\n",
      "js": "const callBefore = (fn, count) => {\n  let counter = 0;\n  return (...args) => {\n    if (counter < count) {\n      counter++;\n      return fn(...args);\n    }\n    return undefined;\n  };\n};\nexport default callBefore;\n"
    },
    "category": "functional",
    "type": "functions",
    "props": [
      {
        "title": "function",
        "required": true,
        "propDesc": "The function to be called",
        "type": "Function"
      },
      {
        "title": "count",
        "required": true,
        "propDesc": "The number of times the function can be called.",
        "type": "number"
      }
    ]
  },
  {
    "name": "chunk",
    "code": {
      "ts": "const chunk = <T,>(\n  array: T[],\n  size: number,\n  config?: {\n    style: 'normal' | 'repeat' | 'remove';\n  },\n): T[][] => {\n  const result: T[][] = [];\n\n  // Push the chunks into the result array\n  for (let i = 0; i < array.length; i += size) {\n    result.push(array.slice(i, i + size));\n  }\n\n  if (config?.style === 'remove' && result[result.length - 1].length !== size) {\n    result.pop(); // Remove the last chunk if it doesn't match the size\n  } else if (config?.style === 'repeat') {\n    // Repeat elements from the start if the last chunk is smaller\n    const lastChunk = result[result.length - 1];\n    if (lastChunk.length < size) {\n      const elementsNeeded = size - lastChunk.length;\n      const repeatedElements = array.slice(0, elementsNeeded); // Get elements from the start\n      result[result.length - 1] = lastChunk.concat(repeatedElements); // Fill the last chunk\n    }\n  }\n\n  return result;\n};\n\nexport default chunk;\n",
      "js": "const chunk = (array, size, config) => {\n  const result = [];\n  // Push the chunks into the result array\n  for (let i = 0; i < array.length; i += size) {\n    result.push(array.slice(i, i + size));\n  }\n  if (config?.style === 'remove' && result[result.length - 1].length !== size) {\n    result.pop(); // Remove the last chunk if it doesn't match the size\n  } else if (config?.style === 'repeat') {\n    // Repeat elements from the start if the last chunk is smaller\n    const lastChunk = result[result.length - 1];\n    if (lastChunk.length < size) {\n      const elementsNeeded = size - lastChunk.length;\n      const repeatedElements = array.slice(0, elementsNeeded); // Get elements from the start\n      result[result.length - 1] = lastChunk.concat(repeatedElements); // Fill the last chunk\n    }\n  }\n  return result;\n};\nexport default chunk;\n"
    },
    "category": "arrays",
    "type": "functions",
    "props": [
      {
        "title": "array",
        "required": true,
        "propDesc": "The array to be processed into chunks.",
        "type": "array"
      },
      {
        "title": "size",
        "required": true,
        "propDesc": "The desired length of each chunk.",
        "type": "number"
      },
      {
        "title": "config.style",
        "required": false,
        "defaultValue": "normal",
        "propDesc": "Determines the behavior of the last chunk: 'normal' keeps it as is, 'repeat' fills the last chunk with elements from the start if it doesn't fit the specified size, and 'remove' truncates the last chunk if its length is not equal to the specified size.",
        "type": "enum",
        "enums": [
          "normal",
          "repeat",
          "remove"
        ]
      }
    ]
  },
  {
    "name": "compact",
    "code": {
      "ts": "const compact = <T,>(array: T[], strict: boolean = false): T[] => {\n  let truthy = array.filter((item) => {\n    // remove all falsy values and excluded values\n    return Boolean(item);\n  });\n\n  if (strict) {\n    // remove all empty objects\n    truthy = truthy.filter((item) => {\n      if (typeof item === 'object' && !(item instanceof Array)) {\n        return Object.keys(item as object).length > 0;\n      }\n      return true;\n    });\n    // remove all empty arrays\n    truthy = truthy.filter((item) => {\n      if (Array.isArray(item)) {\n        return (item as []).length > 0;\n      }\n      return true;\n    });\n  }\n  return truthy;\n};\n\nexport default compact;\n",
      "js": "const compact = (array, strict = false) => {\n  let truthy = array.filter((item) => {\n    // remove all falsy values and excluded values\n    return Boolean(item);\n  });\n  if (strict) {\n    // remove all empty objects\n    truthy = truthy.filter((item) => {\n      if (typeof item === 'object' && !(item instanceof Array)) {\n        return Object.keys(item).length > 0;\n      }\n      return true;\n    });\n    // remove all empty arrays\n    truthy = truthy.filter((item) => {\n      if (Array.isArray(item)) {\n        return item.length > 0;\n      }\n      return true;\n    });\n  }\n  return truthy;\n};\nexport default compact;\n"
    },
    "category": "arrays",
    "type": "functions",
    "props": [
      {
        "title": "array",
        "required": true,
        "propDesc": "The array to process.",
        "type": "array"
      },
      {
        "title": "strict",
        "required": false,
        "defaultValue": "false",
        "propDesc": "If true, also removes empty objects and arrays from the array.",
        "type": "boolean"
      }
    ]
  },
  {
    "name": "count",
    "code": {
      "ts": "const count = <A extends any[], R>(fn: (...args: A) => R) => {\n  let callCount = 0;\n\n  const wrapper = (...args: A): R => {\n    callCount++;\n    const result = fn(...args);\n    return result;\n  };\n\n  const getCount: () => number = () => callCount;\n  wrapper.getCount = getCount;\n\n  return wrapper;\n};\n\nexport default count;\n",
      "js": "const count = (fn) => {\n  let callCount = 0;\n  const wrapper = (...args) => {\n    callCount++;\n    const result = fn(...args);\n    return result;\n  };\n  const getCount = () => callCount;\n  wrapper.getCount = getCount;\n  return wrapper;\n};\nexport default count;\n"
    },
    "category": "functional",
    "type": "functions",
    "props": [
      {
        "title": "function",
        "required": true,
        "propDesc": "The function to count the number of times it is called.",
        "type": "Function"
      }
    ]
  },
  {
    "name": "debounce",
    "code": {
      "ts": "function debounce<A extends any[]>(\n  fn: (...args: A) => void,\n  delay: number = 300,\n) {\n  let timer: any;\n  return (...args: A) => {\n    clearTimeout(timer);\n    timer = setTimeout(() => {\n      fn(...args);\n    }, delay);\n  };\n}\n\nexport default debounce;\n",
      "js": "function debounce(fn, delay = 300) {\n  let timer;\n  return (...args) => {\n    clearTimeout(timer);\n    timer = setTimeout(() => {\n      fn(...args);\n    }, delay);\n  };\n}\nexport default debounce;\n"
    },
    "category": "functional",
    "type": "functions",
    "props": [
      {
        "title": "function",
        "required": true,
        "propDesc": "The function to to debounce.",
        "type": "Function"
      },
      {
        "title": "delay",
        "required": true,
        "defaultValue": "300",
        "type": "number",
        "propDesc": "The delay time for debounce in milliseconds"
      }
    ]
  },
  {
    "name": "filterObj",
    "code": {
      "ts": "const filterObj = <T extends Record<string, unknown>>(\n  obj: T,\n  predicate: (value: T[keyof T], key: keyof T) => boolean,\n): Partial<T> => {\n  const result: Partial<T> = {};\n\n  for (const key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      if (predicate(obj[key], key)) {\n        result[key] = obj[key]; // Include the property if the predicate returns true\n      }\n    }\n  }\n\n  return result;\n};\n\nexport default filterObj;\n",
      "js": "const filterObj = (obj, predicate) => {\n  const result = {};\n  for (const key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      if (predicate(obj[key], key)) {\n        result[key] = obj[key]; // Include the property if the predicate returns true\n      }\n    }\n  }\n  return result;\n};\nexport default filterObj;\n"
    },
    "category": "objects",
    "type": "functions",
    "props": [
      {
        "title": "object",
        "required": true,
        "propDesc": "The object to filter.",
        "type": "object"
      },
      {
        "title": "predicate",
        "required": true,
        "propDesc": "A function that takes the value, key, object and returns true if the property should be included.",
        "type": "(value, key, object) => boolean"
      }
    ]
  },
  {
    "name": "getLocalStorageItem",
    "code": {
      "ts": "type GetConfig<Value> =\n  | {\n      defaultParser: boolean;\n    }\n  | ((storedValue: string) => Value);\n\nconst getLocalStorageItem = <Value,>(\n  key: string,\n  defaultValue: Value,\n  config: GetConfig<Value> = {\n    defaultParser: true,\n  },\n): Value => {\n  if (typeof window === 'undefined' || !('localStorage' in window)) {\n    return defaultValue;\n  }\n\n  const storedValue = localStorage.getItem(key);\n  if (!storedValue) return defaultValue;\n\n  try {\n    if (typeof config === 'object' && config.defaultParser) {\n      return JSON.parse(storedValue) as Value;\n    } else if (typeof config === 'function') {\n      return config(storedValue);\n    }\n    return storedValue as unknown as Value;\n  } catch {\n    return defaultValue;\n  }\n};\n\nexport default getLocalStorageItem;\n",
      "js": "const getLocalStorageItem = (\n  key,\n  defaultValue,\n  config = {\n    defaultParser: true,\n  },\n) => {\n  if (typeof window === 'undefined' || !('localStorage' in window)) {\n    return defaultValue;\n  }\n  const storedValue = localStorage.getItem(key);\n  if (!storedValue) return defaultValue;\n  try {\n    if (typeof config === 'object' && config.defaultParser) {\n      return JSON.parse(storedValue);\n    } else if (typeof config === 'function') {\n      return config(storedValue);\n    }\n    return storedValue;\n  } catch {\n    return defaultValue;\n  }\n};\nexport default getLocalStorageItem;\n"
    },
    "category": "web-api",
    "type": "functions",
    "props": [
      {
        "title": "key",
        "required": true,
        "propDesc": "The key under which the value is stored in local storage.",
        "type": "string"
      },
      {
        "title": "defaultValue",
        "required": true,
        "propDesc": "The default value to return if the item doesn't exist in local storage.",
        "type": "Value"
      },
      {
        "title": "config",
        "required": false,
        "defaultValue": "{ defaultParser: true }",
        "propDesc": "An optional configuration object or function for parsing the stored value.",
        "type": "GetConfig<Value>"
      }
    ]
  },
  {
    "name": "insert",
    "code": {
      "ts": "const insert = <T,>(\n  arr: T[],\n  index: number,\n  [...items]: T[],\n  recursive: boolean = false,\n): T[] => {\n  const isNegativeIndex = index < 0;\n\n  if (isNegativeIndex) {\n    throw new Error('Negative index is not supported!');\n  }\n\n  if (!recursive) {\n    const newArr = [...arr.slice(0, index), ...items, ...arr.slice(index)];\n    return newArr;\n  } else {\n    const shouldInsert = Math.floor(arr.length / index);\n    let newArr = [...arr];\n    for (let i = 0; i < shouldInsert; i++) {\n      const insertIndex = (i + 1) * index + i * items.length;\n      newArr = [\n        ...newArr.slice(0, insertIndex),\n        ...items,\n        ...newArr.slice(insertIndex),\n      ];\n    }\n    return newArr;\n  }\n};\n\nexport default insert;\n",
      "js": "const insert = (arr, index, [...items], recursive = false) => {\n  const isNegativeIndex = index < 0;\n  if (isNegativeIndex) {\n    throw new Error('Negative index is not supported!');\n  }\n  if (!recursive) {\n    const newArr = [...arr.slice(0, index), ...items, ...arr.slice(index)];\n    return newArr;\n  } else {\n    const shouldInsert = Math.floor(arr.length / index);\n    let newArr = [...arr];\n    for (let i = 0; i < shouldInsert; i++) {\n      const insertIndex = (i + 1) * index + i * items.length;\n      newArr = [\n        ...newArr.slice(0, insertIndex),\n        ...items,\n        ...newArr.slice(insertIndex),\n      ];\n    }\n    return newArr;\n  }\n};\nexport default insert;\n"
    },
    "category": "arrays",
    "type": "functions",
    "props": [
      {
        "title": "array",
        "required": true,
        "propDesc": "The array to process.",
        "type": "array"
      },
      {
        "title": "index",
        "required": true,
        "propDesc": "The index at which to insert the elements.",
        "type": "number"
      },
      {
        "title": "items",
        "required": true,
        "propDesc": "The elements to insert into the array.",
        "type": "array"
      },
      {
        "title": "strict",
        "required": false,
        "defaultValue": "false",
        "propDesc": "Indicates whether to insert elements recursively. If true, the elements will be inserted at every nth index.",
        "type": "boolean"
      }
    ]
  },
  {
    "name": "mapObj",
    "code": {
      "ts": "const mapObj = <T, U>(\n  obj: Record<string, T>,\n  callback: (value: T, key: string, obj: Record<string, T>) => U,\n): Record<string, U> => {\n  const result: Record<string, U> = {};\n\n  // loop through each key in the object\n  for (const key in obj) {\n    // check if the key is a property of the object\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      result[key] = callback(obj[key], key, obj);\n    }\n  }\n\n  return result;\n};\n\nexport default mapObj;\n",
      "js": "const mapObj = (obj, callback) => {\n  const result = {};\n  // loop through each key in the object\n  for (const key in obj) {\n    // check if the key is a property of the object\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      result[key] = callback(obj[key], key, obj);\n    }\n  }\n  return result;\n};\nexport default mapObj;\n"
    },
    "category": "objects",
    "type": "functions",
    "props": [
      {
        "title": "object",
        "required": true,
        "propDesc": "The object to process.",
        "type": "object"
      },
      {
        "title": "callback",
        "required": true,
        "propDesc": "The callback function to apply to each property. It receives the value, key, and object as arguments.",
        "type": "function"
      }
    ]
  },
  {
    "name": "nTimes",
    "code": {
      "ts": "const nTimes = <T,>(fn: (i: number) => T, n: number = 1): T[] => {\n  if (n < 0) {\n    throw new Error('n must be greater than 0');\n  }\n  let result: T[] = [];\n  for (let i = 0; i < n; i++) {\n    result.push(fn(i));\n  }\n  return result;\n};\n\nexport default nTimes;\n",
      "js": "const nTimes = (fn, n = 1) => {\n  if (n < 0) {\n    throw new Error('n must be greater than 0');\n  }\n  let result = [];\n  for (let i = 0; i < n; i++) {\n    result.push(fn(i));\n  }\n  return result;\n};\nexport default nTimes;\n"
    },
    "category": "functional",
    "type": "functions",
    "props": [
      {
        "title": "function",
        "required": true,
        "propDesc": "The function called `n` times. The function receives the current iteration index as an argument.",
        "type": "Function"
      },
      {
        "title": "n",
        "required": false,
        "defaultValue": "1",
        "propDesc": "The number of times to call the function.",
        "type": "number"
      }
    ]
  },
  {
    "name": "nand",
    "code": {
      "ts": "const nand = (...args: unknown[]) => {\n  if (args.length === 0) return false;\n  const and = args.every((arg) => Boolean(arg));\n  return !and;\n};\n\nexport default nand;\n",
      "js": "const nand = (...args) => {\n  if (args.length === 0) return false;\n  const and = args.every((arg) => Boolean(arg));\n  return !and;\n};\nexport default nand;\n"
    },
    "category": "gates",
    "type": "functions",
    "props": [
      {
        "title": "args",
        "required": true,
        "propDesc": "The arguments to perform the NAND operation on.",
        "type": "unknown[]"
      }
    ]
  },
  {
    "name": "nor",
    "code": {
      "ts": "const nor = (...args: any[]) => {\n  if (args.length === 0) return false;\n  const or = args.some((arg) => Boolean(arg));\n  return !or;\n};\n\nexport default nor;\n",
      "js": "const nor = (...args) => {\n  if (args.length === 0) return false;\n  const or = args.some((arg) => Boolean(arg));\n  return !or;\n};\nexport default nor;\n"
    },
    "category": "gates",
    "type": "functions",
    "props": [
      {
        "title": "args",
        "required": true,
        "propDesc": "The arguments to perform the NOR operation on.",
        "type": "unknown[]"
      }
    ]
  },
  {
    "name": "omit",
    "code": {
      "ts": "const omit = <T, K extends keyof T>(obj: T, keys: K[]): Omit<T, K> => {\n  const newObj = { ...obj };\n  keys.forEach((key) => delete newObj[key]);\n  return newObj as Omit<T, K>;\n};\n\nexport default omit;\n",
      "js": "const omit = (obj, keys) => {\n  const newObj = { ...obj };\n  keys.forEach((key) => delete newObj[key]);\n  return newObj;\n};\nexport default omit;\n"
    },
    "category": "objects",
    "type": "functions",
    "props": [
      {
        "title": "object",
        "required": true,
        "propDesc": "The object to omit keys from.",
        "type": "object"
      },
      {
        "title": "keys",
        "required": true,
        "propDesc": "An array of keys to omit from the object. The keys must be of the same type as the keys of the input object.",
        "type": "string[]"
      }
    ]
  },
  {
    "name": "once",
    "code": {
      "ts": "const once = <T, S extends any[]>(\n  fn: (...args: S) => T,\n): ((...args: S) => T | undefined) => {\n  let isCalled = false;\n  return (...args: S): T | undefined => {\n    if (!isCalled) {\n      isCalled = true;\n      return fn(...args);\n    }\n    return undefined;\n  };\n};\n\nexport default once;\n",
      "js": "const once = (fn) => {\n  let isCalled = false;\n  return (...args) => {\n    if (!isCalled) {\n      isCalled = true;\n      return fn(...args);\n    }\n    return undefined;\n  };\n};\nexport default once;\n"
    },
    "category": "functional",
    "type": "functions",
    "props": [
      {
        "title": "function",
        "required": true,
        "propDesc": "The function to be called",
        "type": "Function"
      }
    ]
  },
  {
    "name": "or",
    "code": {
      "ts": "const or = (...args: unknown[]) => {\n  return args.some((arg) => Boolean(arg));\n};\n\nexport default or;\n",
      "js": "const or = (...args) => {\n  return args.some((arg) => Boolean(arg));\n};\nexport default or;\n"
    },
    "category": "gates",
    "type": "functions",
    "props": [
      {
        "title": "args",
        "required": true,
        "propDesc": "The arguments to perform the OR operation on.",
        "type": "unknown[]"
      }
    ]
  },
  {
    "name": "partition",
    "code": {
      "ts": "const partition = <T,>(\n  arr: T[],\n  predicate: (value: T, i: number, arr: T[]) => boolean,\n): [T[], T[]] => {\n  const pass: T[] = [];\n  const fail: T[] = [];\n  arr.forEach((...args) => {\n    // run the predicate function on each element in the array\n    // and push the element to the appropriate array\n    (predicate(...args) ? pass : fail).push(args[0]);\n  });\n  return [pass, fail];\n};\n\nexport default partition;\n",
      "js": "const partition = (arr, predicate) => {\n  const pass = [];\n  const fail = [];\n  arr.forEach((...args) => {\n    // run the predicate function on each element in the array\n    // and push the element to the appropriate array\n    (predicate(...args) ? pass : fail).push(args[0]);\n  });\n  return [pass, fail];\n};\nexport default partition;\n"
    },
    "category": "arrays",
    "type": "functions",
    "props": [
      {
        "title": "array",
        "required": true,
        "propDesc": "The array from which to partition elements.",
        "type": "array"
      },
      {
        "title": "predicate",
        "required": true,
        "propDesc": "The function used to determine the partition. It should return a boolean value.",
        "type": "function"
      }
    ]
  },
  {
    "name": "pick",
    "code": {
      "ts": "const pick = <T, K extends keyof T>(obj: T, keys: K[]): Pick<T, K> => {\n  const newObj: any = {};\n  keys.forEach((key) => {\n    newObj[key] = obj[key];\n  });\n  return newObj as Pick<T, K>;\n};\n\nexport default pick;\n",
      "js": "const pick = (obj, keys) => {\n  const newObj = {};\n  keys.forEach((key) => {\n    newObj[key] = obj[key];\n  });\n  return newObj;\n};\nexport default pick;\n"
    },
    "category": "objects",
    "type": "functions",
    "props": [
      {
        "title": "object",
        "required": true,
        "propDesc": "The object to pick keys from.",
        "type": "object"
      },
      {
        "title": "keys",
        "required": true,
        "propDesc": "An array of keys to pick from the object. The keys must be of the same type as the keys of the input object.",
        "type": "string[]"
      }
    ]
  },
  {
    "name": "remove",
    "code": {
      "ts": "const remove = <T,>(array: T[], index: number | number[]): T[] => {\n  const len = array.length;\n  if (Array.isArray(index)) {\n    // convert negative indices to their positive counterparts\n    const indices = index.map((i) => (i < 0 ? len + i : i));\n    return array.filter((_, i) => !indices.includes(i));\n  }\n  index = index < 0 ? len + index : index;\n  return array.filter((_, i) => i !== index);\n};\n\nexport default remove;\n",
      "js": "const remove = (array, index) => {\n  const len = array.length;\n  if (Array.isArray(index)) {\n    // convert negative indices to their positive counterparts\n    const indices = index.map((i) => (i < 0 ? len + i : i));\n    return array.filter((_, i) => !indices.includes(i));\n  }\n  index = index < 0 ? len + index : index;\n  return array.filter((_, i) => i !== index);\n};\nexport default remove;\n"
    },
    "category": "arrays",
    "type": "functions",
    "props": [
      {
        "title": "array",
        "required": true,
        "propDesc": "The array to process.",
        "type": "array"
      },
      {
        "title": "index(s)",
        "required": true,
        "propDesc": "The index(es) of the array to be removed.",
        "type": "number | number[]"
      }
    ]
  },
  {
    "name": "renameKeys",
    "code": {
      "ts": "const renameKeys = <\n  T extends Record<string, unknown>,\n  K extends keyof T,\n  N extends string,\n>(\n  obj: T,\n  keys: Array<{ old: K; new: N }>,\n): Omit<T, K> & Record<N, T[K]> => {\n  const newObj: Record<string, unknown> = { ...obj };\n\n  keys.forEach(({ old: oldKey, new: newKey }) => {\n    // Only rename if the old key exists in the object\n    if (oldKey in newObj) {\n      newObj[newKey] = newObj[oldKey as string];\n      delete newObj[oldKey as string];\n    }\n  });\n\n  return newObj as Omit<T, K> & Record<N, T[K]>;\n};\n\nexport default renameKeys;\n",
      "js": "const renameKeys = (obj, keys) => {\n  const newObj = { ...obj };\n  keys.forEach(({ old: oldKey, new: newKey }) => {\n    // Only rename if the old key exists in the object\n    if (oldKey in newObj) {\n      newObj[newKey] = newObj[oldKey];\n      delete newObj[oldKey];\n    }\n  });\n  return newObj;\n};\nexport default renameKeys;\n"
    },
    "category": "objects",
    "type": "functions",
    "props": [
      {
        "title": "object",
        "required": true,
        "propDesc": "The object from which to rename keys.",
        "type": "object"
      },
      {
        "title": "keys",
        "required": true,
        "propDesc": "An array of objects where each object has 'old' (the key to rename) and 'new' (the new key name) properties.",
        "type": "Array<{ old: string; new: string; }>"
      }
    ]
  },
  {
    "name": "renameKeysByCallback",
    "code": {
      "ts": "const renameKeysByCallback = <\n  T extends Record<string, unknown>,\n  R extends Record<string, any>,\n>(\n  obj: T,\n  predicate: (key: keyof T) => string,\n): R => {\n  const newObj: Record<string, any> = { ...obj };\n\n  for (const key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      const newKey = predicate(key);\n      if (newKey) {\n        newObj[newKey] = obj[key]; // Assign the value to the new key\n        delete newObj[key]; // Delete the old key\n      }\n    }\n  }\n\n  return newObj as R;\n};\n\nexport default renameKeysByCallback;\n",
      "js": "const renameKeysByCallback = (obj, predicate) => {\n  const newObj = { ...obj };\n  for (const key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      const newKey = predicate(key);\n      if (newKey) {\n        newObj[newKey] = obj[key]; // Assign the value to the new key\n        delete newObj[key]; // Delete the old key\n      }\n    }\n  }\n  return newObj;\n};\nexport default renameKeysByCallback;\n"
    },
    "category": "objects",
    "type": "functions",
    "props": [
      {
        "title": "object",
        "required": true,
        "propDesc": "The object from which to rename keys.",
        "type": "object"
      },
      {
        "title": "callback",
        "required": true,
        "propDesc": "A callback function that evaluates the new key name based on the old key.",
        "type": "(oldKey: string) => string"
      }
    ]
  },
  {
    "name": "retry",
    "code": {
      "ts": "const retry = async <T,>(\n  fn: Function,\n  retries: number = 3,\n  delay: number = 1000,\n): Promise<T> => {\n  try {\n    return await fn();\n  } catch (error) {\n    if (retries > 0) {\n      await new Promise((resolve) => setTimeout(resolve, delay));\n      return retry(fn, retries - 1, delay);\n    }\n    throw error;\n  }\n};\n\nexport default retry;\n",
      "js": "const retry = async (fn, retries = 3, delay = 1000) => {\n  try {\n    return await fn();\n  } catch (error) {\n    if (retries > 0) {\n      await new Promise((resolve) => setTimeout(resolve, delay));\n      return retry(fn, retries - 1, delay);\n    }\n    throw error;\n  }\n};\nexport default retry;\n"
    },
    "category": "functional",
    "type": "functions",
    "props": [
      {
        "title": "function",
        "required": true,
        "propDesc": "The function to retry.",
        "type": "Function"
      },
      {
        "title": "retries",
        "required": false,
        "defaultValue": "3",
        "propDesc": "The number of times to retry the function.",
        "type": "number"
      },
      {
        "title": "delay",
        "required": false,
        "defaultValue": "1000",
        "propDesc": "The delay in milliseconds between each retry.",
        "type": "number"
      }
    ]
  },
  {
    "name": "rotate",
    "code": {
      "ts": "const rotate = <T,>(\n  arr: T[],\n  n: number,\n  dir: 'left' | 'right' = 'left',\n): T[] => {\n  if (dir === 'left') {\n    return arr.slice(n, arr.length).concat(arr.slice(0, n));\n  } else {\n    return arr\n      .slice(arr.length - n, arr.length)\n      .concat(arr.slice(0, arr.length - n));\n  }\n};\n\nexport default rotate;\n",
      "js": "const rotate = (arr, n, dir = 'left') => {\n  if (dir === 'left') {\n    return arr.slice(n, arr.length).concat(arr.slice(0, n));\n  } else {\n    return arr\n      .slice(arr.length - n, arr.length)\n      .concat(arr.slice(0, arr.length - n));\n  }\n};\nexport default rotate;\n"
    },
    "category": "arrays",
    "type": "functions",
    "props": [
      {
        "title": "array",
        "required": true,
        "propDesc": "The array to rotate.",
        "type": "array"
      },
      {
        "title": "position",
        "required": true,
        "propDesc": "The number of positions to rotate the array by.",
        "type": "number"
      },
      {
        "title": "direction",
        "required": false,
        "defaultValue": "left",
        "propDesc": "The direction in which to rotate the array.",
        "type": "enum",
        "enums": [
          "left",
          "right"
        ]
      }
    ]
  },
  {
    "name": "sampleArr",
    "code": {
      "ts": "const sampleArr = (size: number) => {\n  if (size < 0) throw new Error('Size must be a positive number');\n  return Array.from({ length: size }, (_, i) => Math.floor(Math.random() * i));\n};\n\nexport default sampleArr;\n",
      "js": "const sampleArr = (size) => {\n  if (size < 0) throw new Error('Size must be a positive number');\n  return Array.from({ length: size }, (_, i) => Math.floor(Math.random() * i));\n};\nexport default sampleArr;\n"
    },
    "category": "arrays",
    "type": "functions",
    "props": [
      {
        "title": "size",
        "required": true,
        "propDesc": "The size of the array to generate, must be a positive number.",
        "type": "number"
      }
    ]
  },
  {
    "name": "sampleObj",
    "code": {
      "ts": "const sampleObj = <R extends Record<string | number | symbol, number>>(\n  ...keys: string[]\n) => {\n  const obj: any = {};\n  keys.forEach((key) => {\n    obj[key] = Math.random();\n  });\n  return obj as R | Record<string, number>;\n};\n\nexport default sampleObj;\n",
      "js": "const sampleObj = (...keys) => {\n  const obj = {};\n  keys.forEach((key) => {\n    obj[key] = Math.random();\n  });\n  return obj;\n};\nexport default sampleObj;\n"
    },
    "category": "objects",
    "type": "functions",
    "props": [
      {
        "title": "keys",
        "required": true,
        "propDesc": "The keys for the object.",
        "type": "string[]"
      }
    ]
  },
  {
    "name": "setLocalStorageItem",
    "code": {
      "ts": "type Config<Value> =\n  | {\n      defaultParser: boolean;\n    }\n  | ((value: Value) => string);\n\nconst setLocalStorageItem = <Value,>(\n  key: string,\n  value: unknown,\n  config: Config<Value> = {\n    defaultParser: true,\n  },\n): boolean => {\n  if (typeof window === 'undefined' || !('localStorage' in window)) {\n    return false;\n  }\n\n  try {\n    let parsed: string = '';\n    if (typeof config === 'object' && config.defaultParser) {\n      if (typeof value === 'object' || Array.isArray(value)) {\n        parsed = JSON.stringify(value);\n      } else {\n        parsed = value as string;\n      }\n    } else if (typeof config === 'function') {\n      parsed = config(value as Value);\n    } else {\n      parsed = value as string;\n    }\n    localStorage.setItem(key, parsed);\n    return true;\n  } catch {\n    return false;\n  }\n};\n\nexport default setLocalStorageItem;\n",
      "js": "const setLocalStorageItem = (\n  key,\n  value,\n  config = {\n    defaultParser: true,\n  },\n) => {\n  if (typeof window === 'undefined' || !('localStorage' in window)) {\n    return false;\n  }\n  try {\n    let parsed = '';\n    if (typeof config === 'object' && config.defaultParser) {\n      if (typeof value === 'object' || Array.isArray(value)) {\n        parsed = JSON.stringify(value);\n      } else {\n        parsed = value;\n      }\n    } else if (typeof config === 'function') {\n      parsed = config(value);\n    } else {\n      parsed = value;\n    }\n    localStorage.setItem(key, parsed);\n    return true;\n  } catch {\n    return false;\n  }\n};\nexport default setLocalStorageItem;\n"
    },
    "category": "web-api",
    "type": "functions",
    "props": [
      {
        "title": "key",
        "required": true,
        "propDesc": "The key under which the value will be stored in localStorage.",
        "type": "string"
      },
      {
        "title": "value",
        "required": true,
        "propDesc": "The value to store in localStorage. Can be any data type.",
        "type": "unknown"
      },
      {
        "title": "config",
        "required": false,
        "defaultValue": "{ defaultParser: true }",
        "propDesc": "Configuration object for parsing. If `defaultParser` is true, values will be JSON stringified by default. Alternatively, a custom parser function can be provided to process the value before storage.",
        "type": "{ defaultParser: boolean } | (value: Value) => string"
      }
    ]
  },
  {
    "name": "shuffleArr",
    "code": {
      "ts": "const shuffleArr = <T,>(arr: T[]) => {\n  const copy = [...arr];\n  for (let i = copy.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [copy[i], copy[j]] = [copy[j], copy[i]];\n  }\n\n  return copy;\n};\n\nexport default shuffleArr;\n",
      "js": "const shuffleArr = (arr) => {\n  const copy = [...arr];\n  for (let i = copy.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [copy[i], copy[j]] = [copy[j], copy[i]];\n  }\n  return copy;\n};\nexport default shuffleArr;\n"
    },
    "category": "arrays",
    "type": "functions",
    "props": [
      {
        "title": "arr",
        "required": true,
        "propDesc": "The array to shuffle.",
        "type": "any[]"
      }
    ]
  },
  {
    "name": "sleep",
    "code": {
      "ts": "const sleep = (ms: number): Promise<true> => {\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      resolve(true);\n    }, ms);\n  });\n};\n\nexport default sleep;\n",
      "js": "const sleep = (ms) => {\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      resolve(true);\n    }, ms);\n  });\n};\nexport default sleep;\n"
    },
    "category": "functional",
    "type": "functions",
    "props": [
      {
        "title": "ms",
        "required": true,
        "propDesc": "The number of milliseconds to sleep.",
        "type": "number"
      }
    ]
  },
  {
    "name": "throttle",
    "code": {
      "ts": "function throttle<A extends any[]>(\n  fn: (...args: A) => void,\n  limit: number,\n): (...args: A) => void {\n  let lastCall = 0;\n  return (...args: A) => {\n    const now = Date.now();\n    if (now - lastCall >= limit) {\n      lastCall = now;\n      fn(...args);\n    }\n  };\n}\n\nexport default throttle;\n",
      "js": "function throttle(fn, limit) {\n  let lastCall = 0;\n  return (...args) => {\n    const now = Date.now();\n    if (now - lastCall >= limit) {\n      lastCall = now;\n      fn(...args);\n    }\n  };\n}\nexport default throttle;\n"
    },
    "category": "functional",
    "type": "functions",
    "props": [
      {
        "title": "function",
        "required": true,
        "propDesc": "The function to to throttle.",
        "type": "Function"
      },
      {
        "title": "limit",
        "required": true,
        "defaultValue": "300",
        "type": "number",
        "propDesc": "The limit for throttle in milliseconds"
      }
    ]
  },
  {
    "name": "timeout",
    "code": {
      "ts": "const timeout = <Return, Err>(\n  fn: (...args: any[]) => Return,\n  time: number,\n  errCb?: (...args: any[]) => Err,\n): ((...args: any[]) => Promise<Return>) => {\n  return (...args: any[]) => {\n    return new Promise<any>((resolve, reject) => {\n      const timer = setTimeout(() => {\n        if (errCb) reject(errCb(...args));\n        else {\n          reject(new Error('Function timed out'));\n        }\n      }, time);\n\n      // Wrap fn call in Promise.resolve to handle both sync and async functions\n      Promise.resolve(fn(...args))\n        .then((result: Return) => {\n          clearTimeout(timer);\n          resolve(result);\n        })\n        .catch((err: Err) => {\n          clearTimeout(timer);\n          reject(err);\n        });\n    });\n  };\n};\n\nexport default timeout;\n",
      "js": "const timeout = (fn, time, errCb) => {\n  return (...args) => {\n    return new Promise((resolve, reject) => {\n      const timer = setTimeout(() => {\n        if (errCb) reject(errCb(...args));\n        else {\n          reject(new Error('Function timed out'));\n        }\n      }, time);\n      // Wrap fn call in Promise.resolve to handle both sync and async functions\n      Promise.resolve(fn(...args))\n        .then((result) => {\n          clearTimeout(timer);\n          resolve(result);\n        })\n        .catch((err) => {\n          clearTimeout(timer);\n          reject(err);\n        });\n    });\n  };\n};\nexport default timeout;\n"
    },
    "category": "functional",
    "type": "functions",
    "props": [
      {
        "title": "function",
        "required": true,
        "propDesc": "The function to be wrapped with a timeout.",
        "type": "Function"
      },
      {
        "title": "time",
        "required": true,
        "propDesc": "The timeout duration in milliseconds.",
        "type": "number"
      },
      {
        "title": "errCb",
        "required": false,
        "propDesc": "Optional error callback function to handle timeout errors. If not provided, the promise will be rejected with an error message.",
        "type": "Function"
      }
    ]
  },
  {
    "name": "tryCatch",
    "code": {
      "ts": "type TryCatchReturn<Err, Return> = [Err, undefined] | [undefined, Return];\n\nconst tryCatch = <Err extends Error, Return>(\n  fn: () => Return,\n): TryCatchReturn<Err, Return> => {\n  let data: Return | undefined = undefined;\n  let err: Err | undefined = undefined;\n\n  try {\n    data = fn();\n  } catch (error) {\n    err = error as Err;\n  }\n  return [err, data] as TryCatchReturn<Err, Return>;\n};\n\nexport default tryCatch;\n",
      "js": "const tryCatch = (fn) => {\n  let data = undefined;\n  let err = undefined;\n  try {\n    data = fn();\n  } catch (error) {\n    err = error;\n  }\n  return [err, data];\n};\nexport default tryCatch;\n"
    },
    "category": "functional",
    "type": "functions",
    "props": [
      {
        "title": "function",
        "required": true,
        "propDesc": "The function to be executed within a try-catch block.",
        "type": "() => any"
      }
    ]
  },
  {
    "name": "tryCatchAsync",
    "code": {
      "ts": "type TryCatchReturnAsync<Err, Return> = Promise<\n  [Err, undefined] | [undefined, Return]\n>;\n\nconst tryCatchAsync = async <Err extends Error, Return>(\n  fn: () => Promise<Return>,\n): TryCatchReturnAsync<Err, Return> => {\n  try {\n    const result = await fn();\n    return [undefined, result] as [undefined, Return];\n  } catch (error) {\n    return [error as Err, undefined] as [Err, undefined];\n  }\n};\n\nexport default tryCatchAsync;\n",
      "js": "const tryCatchAsync = async (fn) => {\n  try {\n    const result = await fn();\n    return [undefined, result];\n  } catch (error) {\n    return [error, undefined];\n  }\n};\nexport default tryCatchAsync;\n"
    },
    "category": "functional",
    "type": "functions",
    "props": [
      {
        "title": "fn",
        "required": true,
        "propDesc": "An async function that returns a Promise. It will be executed within a try-catch to handle success or error.",
        "type": "Function"
      }
    ]
  },
  {
    "name": "unique",
    "code": {
      "ts": "const unique = <T,>(arr: T[]): T[] => {\n  return [...new Set(arr)];\n};\n\nexport default unique;\n",
      "js": "const unique = (arr) => {\n  return [...new Set(arr)];\n};\nexport default unique;\n"
    },
    "category": "arrays",
    "type": "functions",
    "props": [
      {
        "title": "arr",
        "required": true,
        "propDesc": "The array to process",
        "type": "any[]"
      }
    ]
  },
  {
    "name": "zip",
    "code": {
      "ts": "type Args<T extends Array<Array<unknown>>> = {\n  arr: T;\n  strict?: boolean;\n};\n\nconst zip = <T extends Array<Array<unknown>>>({\n  arr,\n  strict = false,\n}: Args<T>): T => {\n  const maxIndex = arr.map((a) => a.length).reduce((a, b) => Math.max(a, b), 0);\n  const minIndex = arr\n    .map((a) => a.length)\n    .reduce((a, b) => Math.min(a, b), maxIndex);\n\n  let result = [] as unknown[][];\n\n  const upto = strict ? minIndex : maxIndex;\n\n  for (let i = 0; i < upto; i++) {\n    const zip = arr.map((a) => a[i]);\n    result.push(zip);\n  }\n\n  return result as T;\n};\n\nexport default zip;\n",
      "js": "const zip = ({ arr, strict = false }) => {\n  const maxIndex = arr.map((a) => a.length).reduce((a, b) => Math.max(a, b), 0);\n  const minIndex = arr\n    .map((a) => a.length)\n    .reduce((a, b) => Math.min(a, b), maxIndex);\n  let result = [];\n  const upto = strict ? minIndex : maxIndex;\n  for (let i = 0; i < upto; i++) {\n    const zip = arr.map((a) => a[i]);\n    result.push(zip);\n  }\n  return result;\n};\nexport default zip;\n"
    },
    "category": "arrays",
    "type": "functions",
    "props": [
      {
        "title": "arr",
        "required": true,
        "propDesc": "The arrays to be zipped.",
        "type": "array[]"
      },
      {
        "title": "strict",
        "required": false,
        "defaultValue": "false",
        "propDesc": "If true, the zipping will be done strictly based on the minimum length of the arrays.",
        "type": "boolean"
      }
    ]
  }
]